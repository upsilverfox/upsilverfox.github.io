{"meta":{"title":"welcome","subtitle":null,"description":null,"author":"银狐","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-20T03:09:41.000Z","updated":"2019-09-21T00:53:37.532Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-09-20T03:05:34.000Z","updated":"2019-09-20T08:07:25.764Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-20T03:08:37.000Z","updated":"2019-09-20T08:06:13.317Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象","slug":"面向对象","date":"2021-03-25T15:43:02.000Z","updated":"2021-03-25T15:55:54.592Z","comments":true,"path":"2021/03/25/面向对象/","link":"","permalink":"http://yoursite.com/2021/03/25/面向对象/","excerpt":"##1、 c++创建结构体（有关有员函数和重载输入输出） 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class student&#123; private: int age; string name; public: void get_stu()&#123; cin &gt;&gt; name &gt;&gt; age; &#125; void out_stu()&#123; cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age; &#125; //定义友元函数 friend max_stu(student s1,student s2);&#125;; void max_stu(student s1,student s2)&#123; if(s1.age &gt; s2.age) s1.out_stu(); else s2.out_stu(); &#125;int main()&#123; student stu[2]; stu[0].get_stu(); stu[1].get_stu(); //使用友元函数 max_stu(stu[0],stu[1]); return 0;&#125;","text":"##1、 c++创建结构体（有关有员函数和重载输入输出） 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class student&#123; private: int age; string name; public: void get_stu()&#123; cin &gt;&gt; name &gt;&gt; age; &#125; void out_stu()&#123; cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age; &#125; //定义友元函数 friend max_stu(student s1,student s2);&#125;; void max_stu(student s1,student s2)&#123; if(s1.age &gt; s2.age) s1.out_stu(); else s2.out_stu(); &#125;int main()&#123; student stu[2]; stu[0].get_stu(); stu[1].get_stu(); //使用友元函数 max_stu(stu[0],stu[1]); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;class student&#123; private: string name; int age; public: friend istream&amp; operator &gt;&gt;(istream&amp; input,student&amp; s)&#123; input&gt;&gt;s.name&gt;&gt;s.age; return input; &#125; friend ostream&amp; operator &lt;&lt;(ostream&amp; output,student&amp; s)&#123; output&lt;&lt;s.name&lt;&lt;\" \"&lt;&lt;s.age; return output; &#125; void out_max(student s[],int n)&#123; int flag=0,max=s[0].age; for(int i=0;i&lt;n;i++) &#123; if(s[i].age&gt;max)&#123; max=s[i].age; flag=i; &#125; &#125; cout&lt;&lt;s[flag]; &#125; &#125;;int main()&#123; int n=3; student s[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; cout&lt;&lt;endl; //找到最大同学并输出 student max; max.out_max(s,n); &#125; ##2、简单的递归 1234567891011121314//f(n)=f(n-1)+f(n+1)#include&lt;iostream&gt;using namespace std;int f(int n)&#123; if(n==1||n==2) return 1; return f(n-1)+f(n-2);&#125;int main()&#123; for(int i=1;i&lt;=10;i++) &#123; cout&lt;&lt;f(i)&lt;&lt;\" \"; &#125; return 0; &#125; 1234567891011121314//f(n)=f(1)+f(2)+...+f(n);#include&lt;iostream&gt;using namespace std; int f(int n)&#123; if(n == 1) return 1; else return n+f(n-1);&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0;&#125;","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c- 链表相加","slug":"c-链表相加","date":"2021-01-14T07:42:15.000Z","updated":"2021-01-14T07:43:48.434Z","comments":true,"path":"2021/01/14/c-链表相加/","link":"","permalink":"http://yoursite.com/2021/01/14/c-链表相加/","excerpt":"","text":"leetcode题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0]输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* l3 = new ListNode(0); ListNode* p = l3; int carry = 0; while(l1!=NULL || l2!=NULL) &#123; int x = (l1!=NULL) ? l1-&gt;val : 0; int y = (l2!=NULL) ? l2-&gt;val : 0; int sum=x+y+carry; carry=sum/10; p-&gt;next = new ListNode(sum % 10); p=p-&gt;next; if(l1!=NULL) l1=l1-&gt;next; if(l2!=NULL) l2=l2-&gt;next; &#125; if(carry&gt;0) &#123; p-&gt;next = new ListNode(carry); &#125; return l3-&gt;next; &#125;&#125;;","categories":[],"tags":[]},{"title":"c++ unodered_set","slug":"c-unodered-set","date":"2021-01-14T07:07:36.000Z","updated":"2021-01-14T07:38:00.404Z","comments":true,"path":"2021/01/14/c-unodered-set/","link":"","permalink":"http://yoursite.com/2021/01/14/c-unodered-set/","excerpt":"","text":"c++的哈希集合(unodered_set) 定义 1234567//定义unordered_set&lt;int&gt; c1;//operator=unordered_set&lt;int&gt; c2;c2 = c1; 基本操作 1234567891011121314151617181920212223242526//查找函数 find() 通过给定主键查找元素 unordered_set&lt;int&gt;::iterator find_iter = c1.find(1); //value出现的次数 count() 返回匹配给定主键的元素的个数 c1.count(1); //返回元素在哪个区域equal_range() 返回值匹配给定搜索值的元素组成的范围 pair&lt;unordered_set&lt;int&gt;::iterator, unordered_set&lt;int&gt;::iterator&gt; pair_equal_range = c1.equal_range(1); //插入函数 emplace() c1.emplace(1); //插入函数 emplace_hint() 使用迭代器 c1.emplace_hint(ite_begin, 1); //插入函数 insert() c1.insert(1); //删除 erase() c1.erase(1);//1.迭代器 value 区域 //清空 clear() c1.clear(); //交换 swap() 容量操作 123456789//判断是否为空 c1.empty(); //获取元素个数 size() c1.size(); //获取最大存储量 max_size() c1.max_size(); 迭代操作 12345678910111213141516//返回头迭代器 begin() unordered_set&lt;int&gt;::iterator ite_begin = c1.begin(); //返回尾迭代器 end() unordered_set&lt;int&gt;::iterator ite_end = c1.end(); //返回const头迭代器 cbegin() unordered_set&lt;int&gt;::const_iterator const_ite_begin = c1.cbegin(); //返回const尾迭代器 cend() unordered_set&lt;int&gt;::const_iterator const_ite_end = c1.cend(); //槽迭代器 unordered_set&lt;int&gt;::local_iterator local_iter_begin = c1.begin(1); unordered_set&lt;int&gt;::local_iterator local_iter_end = c1.end(1); 运用 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。示例 4: 输入: s = “”输出: 0 123456789101112131415161718192021class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; str; int n = s.length(); int rk = -1, ans = 0; //右指针等于-1，枚举左指针位置 for(int i = 0; i &lt;n; i++)&#123; if ( i != 0) //左指针向右移动一格，移除一个元素 str.erase(s[i-1]); while (rk+1 &lt; n &amp;&amp; !str.count(s[rk+1]))&#123; str.insert(s[rk+1]); rk++; &#125; ans = max(ans,rk-i+1); &#125; return ans; &#125; &#125;;","categories":[],"tags":[]},{"title":"在mysql workbench中手动添加表","slug":"在mysql-workbench中手动添加表","date":"2020-05-01T06:32:40.000Z","updated":"2020-05-01T06:39:47.869Z","comments":true,"path":"2020/05/01/在mysql-workbench中手动添加表/","link":"","permalink":"http://yoursite.com/2020/05/01/在mysql-workbench中手动添加表/","excerpt":"","text":"双击打开sql notifier 创建数据库 创建表","categories":[],"tags":[]},{"title":"mysql的基本应用","slug":"mysql的基本应用","date":"2020-05-01T02:57:56.000Z","updated":"2020-05-01T12:09:51.506Z","comments":true,"path":"2020/05/01/mysql的基本应用/","link":"","permalink":"http://yoursite.com/2020/05/01/mysql的基本应用/","excerpt":"","text":"创建数据库命令： create database &lt;数据库名&gt; 显示数据库命令： show databases 删除数据库命令： drop database &lt;数据苦命&gt; 连接数据库命令： use &lt;数据库名&gt; 创建数据表命令： create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 删除数据表命令： drop table &lt;表名&gt; 表的插入命令： insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] 表的查询命令： select &lt;字段1，字段2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt; 删除表中数据命令： delete from 表名 where 表达式 修改表中数据语法：update 表名 set 字段=新值,… where 条件 修改表名命令：rename table 原表名 to 新表名; 一个建库和建表的实例drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(id int(3) auto_increment not null primary key,name char(10) not null,address varchar(50) default ‘深圳’,year date); //建表结束 //以下为插入字段insert into teacher values(”,’allen’,’大连一中’,’1976-10-10′);insert into teacher values(”,’jack’,’大连二中’,’1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令： mysql -uroot -p密码 &lt; c:\\school.sql如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 参考：https://www.cnblogs.com/bluealine/p/7832219.htm 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import pymysql#插入def inser(name): #m123456为mysql数据库的密码，mystudents为数据库 db=pymysql.connect(\"localhost\",\"root\",\"m123456\",\"mystudent\",charset=\"utf8\") cursor=db.cursor() try: cursor.execute(\"insert into students values (%s,now())\",name) db.commit() except: db.rollback() db.close()#删除def delete(name): db=pymysql.connect(\"localhost\",\"root\",\"m123456\",\"mystudent\",charset=\"utf8\") cursor=db.cursor() try: cursor.execute(\"delete from students where Name=%s\",name) db.commit() except: print(\"false\") db.rollback() db.close()#查找所有def selectall(): db=pymysql.connect(\"localhost\",\"root\",\"m123456\",\"mystudent\",charset=\"utf8\") cursor=db.cursor() try: cursor.execute(\"select * from students\") results = cursor.fetchall() print(results) db.commit() except: print(\"false\") db.rollback() db.close()#查找部分def select(name): db=pymysql.connect(\"localhost\",\"root\",\"m123456\",\"mystudent\",charset=\"utf8\") cursor=db.cursor() try: cursor.execute(\"select * from students where Name=%s\",name) results = cursor.fetchall() print(results) db.commit() except: print(\"false\") db.rollback() db.close()#更改def update1(name1,name2): db=pymysql.connect(\"localhost\",\"root\",\"m123456\",\"mystudent\",charset=\"utf8\") cursor=db.cursor() try: #cursor.execute(\"update students set Name='mo' where Name='m'\") sql=\"update students set Name=%s where Name=%s\" cursor.execute(sql,(name1,name2)) db.commit() except: print(\"false\") db.rollback() db.close()if __name__=='__main__': #name1='m' #name2='mo' #update1(name1,name2) inser(\"mo1\") selectall()","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"最长公共子序列的长度","slug":"最长公共子序列的长度","date":"2020-04-28T12:54:46.000Z","updated":"2021-03-25T15:50:11.887Z","comments":true,"path":"2020/04/28/最长公共子序列的长度/","link":"","permalink":"http://yoursite.com/2020/04/28/最长公共子序列的长度/","excerpt":"代码：递归公式： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int find(int *a,int len,int x)&#123; int left=0,right=len,mid=(left+right)/2; while(left&lt;=right) &#123; if(x&gt;a[mid]) left=mid+1; else if(x&lt;a[mid]) right=mid-1; else return mid; mid=(left+right)/2; &#125; return left;&#125;int main()&#123; int i,j,n,a[100],c[100],len; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; c[i]=1000; &#125; len=1; c[0]=a[0]; for(i=1;i&lt;n;i++) &#123; j=find(c,n,a[i]);//二分查找 c[j]=a[i]; if(j&gt;len) len=j+1; &#125; cout&lt;&lt;len;&#125;","text":"代码：递归公式： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int find(int *a,int len,int x)&#123; int left=0,right=len,mid=(left+right)/2; while(left&lt;=right) &#123; if(x&gt;a[mid]) left=mid+1; else if(x&lt;a[mid]) right=mid-1; else return mid; mid=(left+right)/2; &#125; return left;&#125;int main()&#123; int i,j,n,a[100],c[100],len; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; c[i]=1000; &#125; len=1; c[0]=a[0]; for(i=1;i&lt;n;i++) &#123; j=find(c,n,a[i]);//二分查找 c[j]=a[i]; if(j&gt;len) len=j+1; &#125; cout&lt;&lt;len;&#125; 1、递归方程：b[++len] = a[i]; a[i] &gt; b[len];b[j] = a[i]; a[i] &lt;= b[len];代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;using namespace std;int a[1005], b[1005];int binary_search(int len, int i)&#123; int first = 1, last = len; while(first &lt; last)&#123; int mid = first + (last - first) / 2; if (b[mid] &gt;= a[i]) last = mid; else first = mid + 1; &#125; return first;&#125;int main()&#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); b[1] = a[0]; int len = 1; for (int i = 1; i &lt; n; i++)&#123; if (a[i] &gt; b[len])&#123; b[++len] = a[i]; &#125; else &#123; int j = binary_search(len, i); b[j] = a[i]; &#125; &#125; printf(\"%d\\n\", len); return 0;&#125; 2、 递归方程：dp[i] = max(dp[i], dp[j] + 1); a[j] &lt; a[i]; 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#define MAX_N 1000int dp[MAX_N], a[MAX_N];int n;int max(int a, int b)&#123; return a &gt; b? a: b;&#125;int main()&#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); int res = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; i; j++)&#123; if (a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); &#125; res = max(dp[i], res); &#125; printf(\"%d\", res + 1); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2020-04-25T10:13:04.000Z","updated":"2020-04-25T12:49:58.562Z","comments":true,"path":"2020/04/25/快速排序/","link":"","permalink":"http://yoursite.com/2020/04/25/快速排序/","excerpt":"快速排序算法思想","text":"快速排序算法思想 代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt; #include&lt;algorithm&gt;using namespace std;int a[6]=&#123;3,6,1,4,5,2&#125;,n=6; void quicksort(int f,int l)&#123; if(f&gt;=l) return ; int i=f; int j=l; int X=a[i]; while(i&lt;j) &#123; while(a[j]&gt;=X&amp;&amp;i&lt;j) j=j-1; swap(a[i],a[j]); while(a[i]&lt;=X&amp;&amp;i&lt;j) i=i+1; swap(a[i],a[j]); &#125; quicksort(f,j-1); quicksort(j+1,l);&#125;int main()&#123; quicksort(0,n); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; return 0;&#125;","categories":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/categories/排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"直接选择排序","slug":"直接选择排序","date":"2020-04-23T04:15:08.000Z","updated":"2020-04-25T12:50:51.924Z","comments":true,"path":"2020/04/23/直接选择排序/","link":"","permalink":"http://yoursite.com/2020/04/23/直接选择排序/","excerpt":"","text":"代码： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;void straight_insert_sort(int *a,int n)&#123; for(int j=0;j&lt;n-1;j++) &#123; int f=j; //寻找最小值 这种寻找最小值的方法很好之前我不是用这种方法的 for(int k=j+1;k&lt;n;k++) &#123; if(a[k]&gt;a[f]) f=k; &#125; swap(a[j],a[f]); &#125;&#125;int main()&#123; int a[7]=&#123;7,5,1,4,3,2,6&#125;; int n=7; straight_insert_sort(a,n); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; 时间复杂度：平均情况：O(n^2)最好情况：O(n^2)最坏情况：O(n^2) 空间复杂度：辅助空间：O(1) 稳定性 不稳定","categories":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/categories/排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"直接插入排序","slug":"直接插入排序","date":"2020-04-23T03:52:32.000Z","updated":"2020-04-25T12:50:39.306Z","comments":true,"path":"2020/04/23/直接插入排序/","link":"","permalink":"http://yoursite.com/2020/04/23/直接插入排序/","excerpt":"","text":"代码 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;void straight_insert_sort(int *a,int n)&#123; for(int j=1;j&lt;n;j++) &#123; int i=j-1; int x=a[j];//保存索引位置 while(a[i]&lt;x&amp;&amp;i&gt;=0) &#123; a[i+1]=a[i]; i--; &#125; a[i+1]=x;//将x传到下标为i+1的位置 &#125;&#125;int main()&#123; int a[7]=&#123;7,5,1,4,3,2,6&#125;; int n=7; straight_insert_sort(a,n); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; 时间复杂度平均情况：O（n^2）最好情况：O（n）最坏情况：O (n^2)空间复杂度：O（1）稳定性：稳定","categories":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/categories/排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"python—人脸识别","slug":"python—人脸识别","date":"2020-04-16T11:44:01.000Z","updated":"2020-05-01T11:58:47.224Z","comments":true,"path":"2020/04/16/python—人脸识别/","link":"","permalink":"http://yoursite.com/2020/04/16/python—人脸识别/","excerpt":"创建一个images文件夹在同一目录下存放照片作为数据库 代码","text":"创建一个images文件夹在同一目录下存放照片作为数据库 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import face_recognition #导入各个模块import timeimport cv2import osdef face(path): known_names=[] #存储知道人名列表 known_encodings=[]#存储知道的特征值 for image_name in os.listdir(path): load_image = face_recognition.load_image_file(path+image_name) #加载图片 image_face_encoding = face_recognition.face_encodings(load_image)[0] #获得128维特征值 known_names.append(image_name.split(\".\")[0]) known_encodings.append(image_face_encoding) #print(load_image) face_names = [] #存储出现在画面中人脸的名字 video_capture = cv2.VideoCapture(0) #打开摄像头，0表示内置摄像头 process_this_frame = True while True: ret, frame = video_capture.read()# 读取摄像头画面 # opencv的图像是BGR格式的，而我们需要是的RGB格式的，因此需要进行一个转换。 rgb_frame = frame[:, :, ::-1] if process_this_frame: face_locations = face_recognition.face_locations(rgb_frame)#获得所有人脸位置 face_encodings = face_recognition.face_encodings(rgb_frame, face_locations) #获得人脸特征值 for face_encoding in face_encodings: matches = face_recognition.compare_faces(known_encodings, face_encoding,tolerance=0.5) if True in matches: first_match_index = matches.index(True) name = known_names[first_match_index] else: name=\"unknown\" face_names.append(name) process_this_frame = not process_this_frame # 将捕捉到的人脸显示出来 for (top, right, bottom, left), name in zip(face_locations, face_names): cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2) # 画人脸矩形框 # 加上人名标签 cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED) font = cv2.FONT_HERSHEY_DUPLEX #字体格式 cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1) cv2.imshow('frame', frame)#展示图像 if cv2.waitKey(1) &amp; 0xFF == ord('q'):# 按Q退出 break video_capture.release() cv2.destroyAllWindows() print(time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))) face_name=[] face_name=set(face_names) for i in face_name: print(i+\" go into the classroom\")if __name__=='__main__': face(\"./images/\") #存放已知图像路径 参考：https://blog.csdn.net/weixin_42365428/article/details/88735329","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"组合数学重要公式","slug":"组合数学重要公式","date":"2020-04-16T07:35:46.000Z","updated":"2020-04-16T11:47:44.618Z","comments":true,"path":"2020/04/16/组合数学重要公式/","link":"","permalink":"http://yoursite.com/2020/04/16/组合数学重要公式/","excerpt":"","text":"Fibonacci数列","categories":[],"tags":[]},{"title":"将本机的用户名更改为英文","slug":"将本机的用户名更改为英文","date":"2020-04-16T03:33:13.000Z","updated":"2020-04-16T04:51:29.446Z","comments":true,"path":"2020/04/16/将本机的用户名更改为英文/","link":"","permalink":"http://yoursite.com/2020/04/16/将本机的用户名更改为英文/","excerpt":"目前需要用到的是java中eclipse的安装 介绍 win10启用administrator账户","text":"目前需要用到的是java中eclipse的安装 介绍 win10启用administrator账户 以管理员身份运行命令提示符窗口，输入以下命令：net user administrator /active:yes 启用Administrator帐户 重命名用户文件夹名 用快捷键win+r，进入命令端口输入regedit点击确定 进入注册表，定位到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList接着在ProfileList文件夹下的分支找到含有ProfileImagePath并指向你的用户文件夹的值 双击ProfileImagePath，跳出键值设置，直接将用户名改成你要的名字， 点击确定按钮， 参考：https://blog.csdn.net/weixin_40715070/article/details/104283351","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-16T03:26:45.599Z","updated":"2020-04-16T03:26:45.599Z","comments":true,"path":"2020/04/16/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"c-贪心算法解决最小生成树","slug":"c-贪心算法解决最小生成树","date":"2020-04-14T02:09:42.000Z","updated":"2020-05-01T13:29:22.845Z","comments":true,"path":"2020/04/14/c-贪心算法解决最小生成树/","link":"","permalink":"http://yoursite.com/2020/04/14/c-贪心算法解决最小生成树/","excerpt":"","text":"生成最小生成树的Kruakal算法Kruakal算法只与边有关，适用于稀疏图。算法思想： 难点在于判断回路是否形成。看是否有回路这里主要是使用并查集的方法判断,如果加入的点有回路则边的两点有共同的父节点。即find[x]==find[y]. 并查集代码： 1234567891011121314151617//初始化int fa[maxn];void init(int n)&#123; for(int i=0;i&lt;=n;i++) fa[i]=i;&#125;//查找父节点int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;// 合并void merge(int i,int j)&#123; fa[find(i)]=find(j);&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;time.h&gt; #include&lt;cmath&gt;#include&lt;vector&gt;#define maxn 1024using namespace std;long long n,matrix[maxn][maxn],fa[maxn],sum=0,len=0;//int s=0;void rand_seed()&#123; int seed = static_cast&lt;int&gt;(time(0)); srand(seed);&#125;//结构化点与边、权值 struct GVE&#123; int x,y,w;&#125;G[maxn];//cmp用于排序 内部比交 int cmp(GVE a,GVE b)&#123; if(a.w!=b.w) return a.w&gt;b.w;//大于符号用于从大到小排序 else return a.x&gt;b.x;&#125;//初始化数据 class init&#123; public: void create() &#123; cout&lt;&lt;\"输入n:\"; cin&gt;&gt;n; //全部赋值为零 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) matrix[i][j]=maxn; //初始化邻接矩阵 for(int i=0;i&lt;n;i++) &#123; if(i==0) &#123; matrix[i][1]=rand()%n+1; matrix[i][2]=rand()%n+1; &#125; else for(int j=i+1;j&lt;n;j++) matrix[i][j]=rand()%n+1; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(matrix[i][j]!=maxn) &#123; G[len].x=i; G[len].y=j; G[len].w=matrix[i][j]; len++; &#125; &#125; &#125; &#125;&#125;;//并查集 void Finit()&#123; for(int i=0;i&lt;n;i++) fa[i]=i;&#125;int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void merge(int x,int y)&#123; fa[find(x)]=find(y);&#125;//打印图void print() &#123; cout&lt;&lt;n&lt;&lt;\"*\"&lt;&lt;n&lt;&lt;\"阶的邻接矩阵：\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) if(matrix[i][j]==maxn) cout&lt;&lt;\"m\"&lt;&lt;\" \"; else cout&lt;&lt;matrix[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; &#125;//kruakal算法void kruakal()&#123; int x,y,w; vector&lt;int&gt; T[3]; while(T[0].size()&lt;n-1) &#123; len--; x=find(G[len].x); y=find(G[len].y); w=G[len].w; if(x!=y) &#123; T[0].push_back(x); T[1].push_back(y); T[2].push_back(w); sum+=w; merge(x,y); &#125; &#125; cout&lt;&lt;\"通过kruakal算法得到的最小生成树：\"&lt;&lt;endl; for(int i=0;i&lt;n-1;i++) &#123; printf(\"边：(%d,%d) 权值：%d\\n\",T[0][i],T[1][i],T[2][i]); &#125; cout&lt;&lt;\"权值和：\"&lt;&lt;sum;&#125; int main()&#123; //数据初始化 init M; rand_seed(); M.create(); Finit(); print(); cout&lt;&lt;endl; sort(G,G+len,cmp); /*测试使用 for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;\"x: \"&lt;&lt;G[i].x&lt;&lt;\" y:\"&lt;&lt;G[i].y&lt;&lt;\" w:\"&lt;&lt;G[i].w&lt;&lt;endl; &#125; cout&lt;&lt;endl; */ kruakal();&#125; 运行结果 经典案列 代码修饰后运行结果： 生成最小生成树prim算法prim算法只与点有关，适用于点较少的稠密矩阵。算法思想： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;iostream&gt;#include&lt;time.h&gt;#define maxn 1024using namespace std;long long matrix[maxn][maxn],n;void rand_seed()&#123; int seed = static_cast&lt;int&gt;(time(0)); srand(seed);&#125;struct GVE&#123; int x,y,w;&#125;G[maxn];class init&#123; public: void create() &#123; cout&lt;&lt;\"输入n:\"; cin&gt;&gt;n; //全部赋值为零 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) matrix[i][j]=maxn; //初始化d对称矩阵 for(int i=0;i&lt;n;i++) &#123; if(i==0) &#123; matrix[i][1]=rand()%n+1; matrix[i][2]=rand()%n+1; &#125; else for(int j=i+1;j&lt;n;j++) matrix[i][j]=rand()%n+1; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;i;j++) &#123; matrix[i][j]=matrix[j][i]; &#125; &#125; &#125;&#125;;//打印图void print() &#123; cout&lt;&lt;n&lt;&lt;\"*\"&lt;&lt;n&lt;&lt;\"阶的邻接矩阵：\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) if(matrix[i][j]==maxn) cout&lt;&lt;\"m\"&lt;&lt;\" \"; else cout&lt;&lt;matrix[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; &#125;void perm()&#123; cout&lt;&lt;\"出发顶点：\"; int x,g=0; cin&gt;&gt;x; //X表示要联通的结点。C1表示边，C2表示权值 int X[maxn],Y[maxn],C1[maxn],C2[maxn]; //初始化数据 X[0]=x; for(int i=0;i&lt;n;i++) Y[i]=i; for(int i=0;i&lt;n;i++) &#123; if(i==x) &#123; for(int k=i;k&lt;n-1;k++) Y[k]=k+1; break; &#125; &#125; int len=n-1; for(int i=0;i&lt;n;i++) &#123; C1[i]=x; C2[i]=maxn; &#125; //计算 while(len!=0) &#123; for(int i=0;i&lt;len;i++) &#123; if(matrix[x][Y[i]]!=maxn) &#123; int b=matrix[x][Y[i]]; if(b&lt;C2[Y[i]]) &#123; C2[Y[i]]=b; C1[Y[i]]=x; &#125; &#125; &#125; int minx=C2[Y[0]],u=0; for(int i=1;i&lt;len;i++) &#123; if(minx&gt;C2[Y[i]]) minx=C2[Y[i]]; &#125; for(int i=0;i&lt;len;i++) &#123; if(minx==C2[Y[i]]) &#123; u=i; break; &#125; &#125; //将外部的点与内部点连接并保存到树中 int z=C1[Y[u]]; G[g].x=Y[u]; G[g].y=z; G[g].w=minx; g++; //更新X，Y； X[n-len]=Y[u]; x=Y[u]; C2[Y[u]]=maxn; for(int i=u;i&lt;len-1;i++) Y[i]=Y[i+1]; len--; &#125; for(int i=0;i&lt;g;i++) &#123; printf(\"边 (%d,%d)\",G[i].x,G[i].y); printf(\" 权值：%d \\n\",G[i].w); &#125; &#125;int main()&#123; //数据初始化 init M; rand_seed(); M.create(); print(); perm(); return 0; &#125; 运行结果： 单元最短路径问题算法思想： 实现： 伪代码： 输入： 一个大于1的整数n. 输出： 一个随机生成的有向图G=（V，E），对于每一条边，有一个非负数字c(u，v)与之相关。 对于每个顶点v∈V,得到从v_0 到v的最短路径的长度。 程序运行时间。 步骤1： 随机生成一个有向图G=（V，E），用rand_seed()函数使得每一次程序运行时随机生成的有向图都不同。 步骤2： 令S=0，V_S=V-v_0。 步骤3： 将与v_0相连接的点v_i的值c赋值给L(v_i),其余将∞赋值给L(v_i)。 步骤4： 从V_S中选出u使得L(u)是最小的，将u从V_S删除，S=S∪{u}。 步骤5： 对于V_S中的所有点w使得L(w)=min(L(w),L(u)+c(u,w))，返回步骤4. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;Windows.h&gt; #define maxn 1024using namespace std;long long n,matrix[maxn][maxn];long long L[maxn],S[maxn],V_S[maxn];//int s=0;void rand_seed()&#123; int seed = static_cast&lt;int&gt;(time(0)); srand(seed);&#125;class init&#123; public: void create() &#123; cout&lt;&lt;\"输入n:\"; cin&gt;&gt;n; //全部赋值为零 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) matrix[i][j]=maxn; //初始化邻接矩阵 for(int i=0;i&lt;n;i++) &#123; if(i==0) &#123; matrix[i][1]=rand()%n; matrix[i][2]=rand()%n; &#125; else for(int j=i+1;j&lt;n;j++) matrix[i][j]=rand()%n; &#125; &#125;&#125;;void print()//打印图 &#123; cout&lt;&lt;n&lt;&lt;\"*\"&lt;&lt;n&lt;&lt;\"阶的邻接矩阵：\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) if(matrix[i][j]==maxn) cout&lt;&lt;\"m\"&lt;&lt;\" \"; else cout&lt;&lt;matrix[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; &#125;void look_min(int l)&#123; //从V-S中选择u使得L[u]最小 int minx=L[V_S[0]]; for(int i=0;i&lt;l;i++) &#123; if(L[V_S[i]]&lt;minx) minx=L[V_S[i]]; &#125; //V-S和S中的值变化 int u=0; for(int i=0;i&lt;l;i++) &#123; if(L[V_S[i]]==minx) &#123; //将u从V_S中删去 u=V_S[i]; S[n-l-1]=i; for(int k=i;k&lt;l-1;k++) V_S[k]=V_S[k+1]; l--; break; &#125; &#125; //对于V_S中的所有点w使得L(w)=min(L(w),L(u)+c(u,w)) for(int k=0;k&lt;l;k++) &#123; L[V_S[k]]=min(L[V_S[k]],L[u]+matrix[u][V_S[k]]); &#125; &#125;int main()&#123; double start = GetTickCount();//计算时间 //数据初始化 init M; rand_seed(); M.create(); //令V_S=V-v0。 for(int i=1;i&lt;n;i++) &#123; V_S[i-1]=i; &#125; //将与v_0相连接的点v_i的值c赋值给L(v_i),其余将∞赋值给L(v_i)。 for(int i=1;i&lt;n;i++) &#123; if(matrix[0][i]!=maxn) L[i]=matrix[0][i]; else L[i]=maxn; &#125; for(int i=0;i&lt;n;i++) &#123; look_min(n-i-1); &#125; double stop = GetTickCount(); //输出 print(); cout&lt;&lt;endl; cout&lt;&lt;\"最短路径：\"&lt;&lt;endl; for(int i=1;i&lt;n;i++) cout&lt;&lt;\"从顶点v0出发到V\"&lt;&lt;i&lt;&lt;\"的最短路径为： \"&lt;&lt;L[i]&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;\"程序运行所需时间：\"&lt;&lt;stop-start&lt;&lt;\" ms\"; return 0;&#125; 结果： 其他的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*测试用立41 2 34 5 62 1 35 1 3 */#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 10000#define m 10000using namespace std;int n;double array[maxn][maxn];double L[m]=&#123;0&#125;;int V[m]=&#123;0&#125;,S[m]=&#123;0&#125;;double cost(int x1,int y1,int h1,int x2,int y2,int h2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))+(h1-h2)*(h1-h2);&#125;void prin()&#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(array[i][j]!=m) cout&lt;&lt;array[i][j]&lt;&lt;\" \"; else cout&lt;&lt;\"m \"; &#125; cout&lt;&lt;endl; &#125;&#125;void Dijkstra()&#123; //初始化v，s,l S[0]=0; for(int i=0;i&lt;n-1;i++) V[i]=i+1; L[0]=m; for(int i=1;i&lt;n;i++) &#123; if(array[0][i]!=m) L[i]=array[0][i]; else L[i]=m; &#125; //关键代码 for(int i=1;i&lt;n;i++) &#123; int len=n-i,u=0;//len为V的长度 //找L[V]最小的一个数 double minx=L[V[0]]; for(int k=1;k&lt;len;k++) &#123; if(minx&gt;L[V[k]]) minx=L[V[k]]; &#125; //记录最小值的下标u，传值给s，将u从V中删除 for(int k=0;k&lt;len;k++) &#123; if(minx==L[V[k]]) &#123; u=V[k]; S[i]=u; for(int j=k;j&lt;len-1;j++) V[j]=V[j+1]; break; &#125; &#125; //更新剩下点即V中的值 //关键代码 for(int k=0;k&lt;len-1;k++) L[V[k]]=min(L[V[k]],L[u]+array[u][V[k]]); &#125;&#125;int main()&#123; cin&gt;&gt;n; int x[n],y[n],h[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;h[i]; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(j&gt;i) &#123; array[i][j]=cost(x[i],y[i],h[i],x[j],y[j],h[j]); &#125; else array[i][j]=m; &#125; &#125; prin(); Dijkstra(); for(int i=1;i&lt;n;i++) cout&lt;&lt;\"v0到\"&lt;&lt;\"v\"&lt;&lt;i&lt;&lt;\"的单源最短路径为： \"&lt;&lt;L[i]&lt;&lt;endl; return 0;&#125; 最终版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;Windows.h&gt; #define maxn 5000using namespace std;long long n,matrix[maxn][maxn];long long L[maxn],S[maxn],V_S[maxn];//int s=0;void rand_seed()&#123; int seed = static_cast&lt;int&gt;(time(0)); srand(seed);&#125;class init&#123; public: void create(int n) &#123; //全部赋值为零 for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) matrix[i][j]=maxn; //初始化邻接矩阵 for(int i=0;i&lt;n;i++) &#123; if(i==0) &#123; matrix[i][1]=rand()%n; matrix[i][2]=rand()%n; &#125; else for(int j=i+1;j&lt;n;j++) matrix[i][j]=rand()%n; &#125; &#125;&#125;;void print()//打印图 &#123; cout&lt;&lt;n&lt;&lt;\"*\"&lt;&lt;n&lt;&lt;\"阶的邻接矩阵：\"&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) if(matrix[i][j]==maxn) cout&lt;&lt;\"m\"&lt;&lt;\" \"; else cout&lt;&lt;matrix[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; &#125;void look_min(int l)&#123; //从V-S中选择u使得L[u]最小 int minx=L[V_S[0]]; for(int i=0;i&lt;l;i++) &#123; if(L[V_S[i]]&lt;minx) minx=L[V_S[i]]; &#125; //V-S和S中的值变化 int u=0; for(int i=0;i&lt;l;i++) &#123; if(L[V_S[i]]==minx) &#123; //将u从V_S中删去 u=V_S[i]; S[n-l-1]=i; for(int k=i;k&lt;l-1;k++) V_S[k]=V_S[k+1]; l--; break; &#125; &#125; //对于V_S中的所有点w使得L(w)=min(L(w),L(u)+c(u,w)) for(int k=0;k&lt;l;k++) &#123; L[V_S[k]]=min(L[V_S[k]],L[u]+matrix[u][V_S[k]]); &#125; &#125;int main()&#123; //数据初始化 cout&lt;&lt;\"输入n:\"; cin&gt;&gt;n; init M; rand_seed(); M.create(n); //令V_S=V-v0。 LARGE_INTEGER nFreq; LARGE_INTEGER nBeginTime; LARGE_INTEGER nEndTime; QueryPerformanceFrequency(&amp;nFreq); QueryPerformanceCounter(&amp;nBeginTime);//开始计时 for(int i=1;i&lt;n;i++) &#123; V_S[i-1]=i; &#125; //将与v_0相连接的点v_i的值c赋值给L(v_i),其余将∞赋值给L(v_i)。 for(int i=1;i&lt;n;i++) &#123; if(matrix[0][i]!=maxn) L[i]=matrix[0][i]; else L[i]=maxn; &#125; for(int i=0;i&lt;n;i++) &#123; look_min(n-i-1); &#125; QueryPerformanceCounter(&amp;nEndTime);//停止计时//输出 print(); cout&lt;&lt;endl; cout&lt;&lt;\"最短路径：\"&lt;&lt;endl; for(int i=1;i&lt;n;i++) cout&lt;&lt;\"从顶点v0出发到V\"&lt;&lt;i&lt;&lt;\"的最短路径为： \"&lt;&lt;L[i]&lt;&lt;endl; double time=(double)(nEndTime.QuadPart-nBeginTime.QuadPart)/(double)nFreq.QuadPart;//计算程序执行时间单位为s cout&lt;&lt;\"程序运行所需时间：\"; cout&lt;&lt;time*1000&lt;&lt;\" ms\"&lt;&lt;endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-大数加法","slug":"c-大数加法","date":"2020-04-08T12:23:40.000Z","updated":"2020-04-25T10:21:33.821Z","comments":true,"path":"2020/04/08/c-大数加法/","link":"","permalink":"http://yoursite.com/2020/04/08/c-大数加法/","excerpt":"题目：【问题描述】 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？【输入格式】输入一行包含两个整数 n。【输出格式】输出一行，包含一个整数，表示满足条件的数的和。【样例输入】 40【样例输出】 574【评测用例规模与约定】 对于 20% 的评测用例，1≤n≤10。 对于 50% 的评测用例，1≤n≤100。 对于 80% 的评测用例，1≤n≤1000。 对于所有评测用例，1≤n≤10000","text":"题目：【问题描述】 小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。 请问，在 1 到 n 中，所有这样的数的和是多少？【输入格式】输入一行包含两个整数 n。【输出格式】输出一行，包含一个整数，表示满足条件的数的和。【样例输入】 40【样例输出】 574【评测用例规模与约定】 对于 20% 的评测用例，1≤n≤10。 对于 50% 的评测用例，1≤n≤100。 对于 80% 的评测用例，1≤n≤1000。 对于所有评测用例，1≤n≤10000 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt; #define maxn 10000using namespace std;int num[maxn];int len;void init()&#123; len=1; num[0]=0;&#125;bool judge(int a)&#123; int t; while(a) &#123; t=a%10; if(t==2||t==0||t==1||t==9) return true; a=a/10; &#125; return false;&#125;int add(int i,int len)&#123; int t=i,n=0,temp[maxn]; while(t)&#123; temp[n]=t%10; t=t/10; n++; &#125; int flag=0; if(n==len&amp;&amp;temp[n-1]+num[len-1]&gt;=10) &#123; for(int i=0;i&lt;=len;i++) &#123; flag=temp[i]+num[i]+flag; num[i]=flag%10; flag=flag/10; &#125; len++; &#125; else for(int i=0;i&lt;=len;i++) &#123; flag=temp[i]+num[i]+flag; num[i]=flag%10; flag=flag/10; &#125; return len; &#125;int main()&#123; int n,sum=0; init(); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; if(judge(i)) // len=add(i,len); &#125; for(int i=len-1;i&gt;=0;i--) &#123; cout&lt;&lt;num[i]; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-递归","slug":"c-递归","date":"2020-04-08T12:19:34.000Z","updated":"2020-04-25T10:22:40.983Z","comments":true,"path":"2020/04/08/c-递归/","link":"","permalink":"http://yoursite.com/2020/04/08/c-递归/","excerpt":"题目1：问题描述 有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？ 例如，长度为4的地面一共有如下5种铺法： 4=1+1+1+1 4=2+1+1 4=1+2+1 4=1+1+2 4=2+2 编程用递归的方法求解上述问题。输入格式 只有一个数N，代表地板的长度输出格式 输出一个数，代表所有不同的瓷砖铺放方法的总数样例输入4样例输出5代码：","text":"题目1：问题描述 有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？ 例如，长度为4的地面一共有如下5种铺法： 4=1+1+1+1 4=2+1+1 4=1+2+1 4=1+1+2 4=2+2 编程用递归的方法求解上述问题。输入格式 只有一个数N，代表地板的长度输出格式 输出一个数，代表所有不同的瓷砖铺放方法的总数样例输入4样例输出5代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int fun(int n)&#123;if(n==1) return 1;if(n==2) return 2;else return fun(n-1)+fun(n-2);&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;fun(n); return 0;&#125; 题目：问题描述 如果一个序列满足下面的性质，我们就将它称为摆动序列： 1. 序列中的所有数都是不大于k的正整数； 2. 序列中至少有两个数。 3. 序列中的数两两不相等； 4. 如果第i – 1个数比第i – 2个数大，则第i个数比第i – 2个数小；如果第i – 1个数比第i – 2个数小，则第i个数比第i – 2个数大。 比如，当k = 3时，有下面几个这样的序列： 1 2 1 3 2 1 2 1 3 2 3 2 3 1 3 1 3 2 一共有8种，给定k，请求出满足上面要求的序列的个数。输入格式 输入包含了一个整数k。（k&lt;=20）输出格式 输出一个整数，表示满足要求的序列个数。样例输入3样例输出8 使用全排列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;set&gt; #include&lt;sstream&gt;#define maxn 20using namespace std;set&lt;string&gt; se[maxn];void is2(string &amp;s,int i)&#123; stringstream ss; ss&lt;&lt;i; ss&gt;&gt;s;&#125;bool issuccess(string str)&#123; for(int i=2;i&lt;str.length();i++) &#123; if((str[i-1]&gt;str[i-2]&amp;&amp;str[i]&gt;str[i-2])||(str[i-1]&lt;str[i-2]&amp;&amp;str[i]&lt;str[i-2])) return false; &#125; return true;&#125;void per(string s,int n,int k)&#123; if(k&gt;=n) &#123; for(int i=3;i&lt;=n;i++) &#123; string s2=s.substr(0,i); if(issuccess(s2)) se[i].insert(s2); &#125; &#125; else for(int i=k;i&lt;n;i++) &#123; swap(s[i],s[k]); per(s,n,k+1); swap(s[i],s[k]); &#125;&#125;int main()&#123; int k,sum=0; cin&gt;&gt;k; string s1; for(int i=1;i&lt;=k;i++) &#123; string s2; is2(s2,i); s1=s1+s2; &#125; per(s1,k,0); for(int i=3;i&lt;=k;i++) sum+=se[i].size(); cout&lt;&lt;k*(k-1)+sum; return 0; &#125; 使用dfs 12345678910111213141516171819202122232425262728293031323334353637383940414243/*dfs深搜+枚举判断每一个数据可以多次使用，所以需要回溯。先用DFS深搜将可能的结果找出来，然后用if条件进行判断当只有两个数的时候一定成立，直接加一就可以否则就要满足 ：(data[t-2]-data[t-3])*(data[t-1]-data[t-3])&lt;0现在解释一下，为什么不需要从头开始将条件判断过来，只需要判断刚刚放进去的数能不能满足就可以。当既不满足t==2又不满足 (data[t-2]-data[t-3])*(data[t-1]-data[t-3])&lt;0条件时，我们直接返回了，没有进行下面的运算，前面的不满足后面无论满足与否都不需要考虑。接下来再解释一下为什么不需要判断t的值和n的值得关系。当t=n+1；时，我们判断的还是前n个数，进入循环以后会发现所有的数都被标记了，没有可以使用的数，会被直接return回去 */#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int sum,n;int data[1000]=&#123;0&#125;,book[1000]=&#123;0&#125;;void bfs(int t)&#123; if(t&gt;1)&#123; if(t==2)&#123; sum++; &#125; else if((data[t-2]-data[t-3])*(data[t-1]-data[t-3])&lt;0)&#123;//数组下标是从0开始的，所以要多减去一个1 sum++; &#125; else return ; &#125; for(int i = 1;i &lt;= n;i++)&#123; if(book[i]==0)&#123; data[t] = i;//标记 book[i] = 1;//标记 bfs(t+1); book[i] = 0;//回溯 &#125; &#125; return ;&#125;int main()&#123; sum=0; scanf(\"%d\",&amp;n); bfs(0); printf(\"%d\\n\",sum); return 0;&#125; 题目：用dfs将1到n的全排列输出 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int book[1000]=&#123;0&#125;,data[1000]=&#123;0&#125;;int n;void dfs(int t)&#123; if(t==n) &#123; for(int i=0;i&lt;n;i++) cout&lt;&lt;data[i]; cout&lt;&lt;endl; &#125; for(int i=1;i&lt;=n;i++) &#123; if(book[i]==0) &#123; data[t]=i; book[i]=1; dfs(t+1); book[i]=0; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(0); return 0;&#125; 题目：（分治递归） 任何一个正整数都可以用2的幂次方表示。例如： 137=27+23+20 同时约定方次用括号来表示，即ab 可表示为a（b）。 由此可知，137可表示为： 2（7）+2（3）+2（0） 进一步：7= 22+2+20 （21用2表示） 3=2+20 所以最后137可表示为： 2（2（2）+2+2（0））+2（2+2（0））+2（0） 又如： 1315=210 +28 +25 +2+1 所以1315最后可表示为： 2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）输入格式 输入包含一个正整数N（N&lt;=20000），为要求分解的整数。输出格式 程序输出包含一行字符串，为符合约定的n的0，2表示（在表示中不能有空格） 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt; #include&lt;algorithm&gt; using namespace std;void divide(int n)&#123; int i; for(i=20;i&gt;=0;i--) &#123; if(n&amp;(1&lt;&lt;i)) break; &#125; cout&lt;&lt;\"2\"; if(i==0||i==2) cout&lt;&lt;\"(\"&lt;&lt;i&lt;&lt;\")\"; if(i!=1&amp;&amp;i!=2&amp;&amp;i!=0) &#123; cout&lt;&lt;\"(\"; divide(i); cout&lt;&lt;\")\"; &#125; if(n-(1&lt;&lt;i)) //如果当前n没有被分解完 &#123; printf(\"+\"); divide(n-(1&lt;&lt;i)); &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; divide(n);&#125; 题目： 最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。 不妨设 An=sin(1–sin(2+sin(3–sin(4+…sin(n))…) Sn=(…(A1+n)A2+n-1)A3+…+2)An+1 FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。输入格式 仅有一个数：N&lt;201。输出格式 请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。样例输入3样例输出((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;void printAn(int k,int n)&#123; if(n+1==k) &#123; return ; &#125; cout&lt;&lt;\"sin(\"&lt;&lt;k; if(k!=n) &#123; if(k%2!=0) cout&lt;&lt;\"-\"; else cout&lt;&lt;\"+\"; &#125; printAn(k+1,n); cout&lt;&lt;\")\";&#125;void printSn(int n)&#123; for(int i=1;i&lt;n;i++) cout&lt;&lt;\"(\"; for(int i=1;i&lt;=n;i++) &#123; if(i!=n) &#123; printAn(1,i); cout&lt;&lt;\"+\"&lt;&lt;n-i+1; cout&lt;&lt;\")\"; &#125; else &#123; printAn(1,i); cout&lt;&lt;\"+\"&lt;&lt;n-i+1; &#125; &#125; &#125;int main()&#123; int n; cin&gt;&gt;n; printSn(n);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-set的用法","slug":"c-set的用法","date":"2020-04-07T13:15:29.000Z","updated":"2020-04-25T10:25:35.776Z","comments":true,"path":"2020/04/07/c-set的用法/","link":"","permalink":"http://yoursite.com/2020/04/07/c-set的用法/","excerpt":"set的各成员函数列表如下: begin()–返回指向第一个元素的迭代器 clear()–清除所有元素 count()–返回某个值元素的个数","text":"set的各成员函数列表如下: begin()–返回指向第一个元素的迭代器 clear()–清除所有元素 count()–返回某个值元素的个数 empty()–如果集合为空，返回true end()–返回指向最后一个元素的迭代器 equal_range()–返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 简单应用1、 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;set&gt; using namespace std;int main()&#123; int a[7]=&#123;1,2,1,1,2,3,4&#125;,c; set&lt;int&gt; b; for(int i=0;i&lt;7;i++) b.insert(a[i]); cout&lt;&lt;b.size()&lt;&lt;endl; set&lt;int&gt;::iterator int1=b.begin(); set&lt;int&gt;::iterator int2=b.end(); for(;int1!=int2;int1++) cout&lt;&lt;*int1&lt;&lt;\" \"; return 0;&#125; 2、 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#define maxn 1024#include&lt;set&gt;using namespace std;long long sum=0,f=1;set&lt;string&gt; sr[maxn];void per(string s,int n,int k)&#123; if(k&gt;=n) &#123; for(int i=1;i&lt;=s.length();i++) &#123; string s2=s.substr(0,i); sr[i-1].insert(s2); &#125; &#125; else for(int i=k;i&lt;n;i++) &#123; swap(s[i],s[k]); per(s,n,k+1); swap(s[i],s[k]); &#125;&#125;int main()&#123; string s1; cin&gt;&gt;s1; per(s1,s1.length(),0); for(int i=0;i&lt;s1.length();i++) cout&lt;&lt;sr[i].size()&lt;&lt;endl;&#125; 3、 ```c++ #include #define maxn 1024 #includeusing namespace std;long long sum=0,f=1;set sr[maxn];int main(){ string s1; cin&gt;&gt;s1; for(int i=0;i&lt;s1.length();i++) { for(int j=1;j&lt;=s1.length();j++) { string s2=s1.substr(i,j); if(s2.length()==j) sr[j-1].insert(s2); } } for(int i=0;i&lt;s1.length();i++) sum+=sr[i].size(); cout&lt;&lt;sum; /* set::iterator int1=sr[0].begin(); set::iterator int2=sr[0].end(); for(;int1!=int2;int1++) cout&lt;&lt;*int1&lt;&lt;&quot; &quot;; return 0; */}","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-找不同的子串","slug":"c-找不同的子串","date":"2020-04-06T13:01:07.000Z","updated":"2020-04-25T10:24:25.528Z","comments":true,"path":"2020/04/06/c-找不同的子串/","link":"","permalink":"http://yoursite.com/2020/04/06/c-找不同的子串/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt; using namespace std;#define MAXN 1011 int n,k;//n=strlen(s); int Rank[MAXN];int tmp[MAXN];char s[MAXN];int lcp[MAXN],sa[MAXN]; /*使用Rank对sa排序*/bool cmpSa(int i, int j)&#123; if(Rank[i] != Rank[j])return Rank[i] &lt; Rank[j]; else &#123; /*以下的Rank[t]。已经是以t开头长度小于等于k/2的， sa[i]的名次。仅仅是以i开头的后缀。而长度不同*/ int ri = i+k &lt;=n? Rank[i+k]:-1; int rj = j+k &lt;= n ? Rank[j+k]:-1; return ri &lt;rj; &#125;&#125; /*计算SA*/void consa()&#123; /*n=strlen(s); 必要时注明*/ /*初始化sa和rank保证两点 1、Rank[i]表示下标为i的是第几大，必须表示出相对大小。能够直接用字符代表其大小 2、sa[1...n]值为1..n*/ for(int i=0;i&lt;=n;i++)&#123; sa[i]=i;Rank[i] = i &lt; n?s[i]:-1; &#125; /*利用长度为k的字符串对长度为2*k的字符串排序*/ for(k=1;k&lt;=n;k*=2)/*注意此代码中k是全局变量 别乱用,循环必须从1開始，由于0*2=0*/ &#123; sort(sa,sa+n+1,cmpSa); tmp[sa[0]] = 0; /*此时tmp仅仅是暂存rank*/ for(int i=1;i&lt;=n;i++)&#123; tmp[sa[i]] = tmp[sa[i-1]] +(cmpSa(sa[i-1],sa[i])?1:0); /*这一句非常关键，等号右側的sa[i]在此循环里表示第i大的长度小于等于k/2的字符串， 从而求出第i大的长度小于等于k的字符串的sa[i]*/ &#125; for(int i=0;i&lt;=n;i++)&#123; Rank[i] = tmp[i]; &#125; &#125;&#125; void construct_lcp()&#123; //n=strlen(s); for(int i=0; i&lt;=n; i++)Rank[sa[i]]=i; int h=0; lcp[0]=0; for(int i=0;i&lt;n;i++) &#123; int j=sa[Rank[i]-1]; if(h&gt;0)h--; for(; j+h&lt;n &amp;&amp; i+h&lt;n; h++) &#123; if(s[j+h]!=s[i+h])break; &#125; lcp[Rank[i]-1]=h; &#125;&#125; int main()&#123; int t,ans; scanf(\"%d\",&amp;t); while(t--) &#123; ans=0; scanf(\"%s\",s); n=strlen(s); consa(); construct_lcp(); for(int i=1;i&lt;=n;i++) &#123; ans+=n-sa[i]-lcp[i-1]; &#125; printf(\"%d\\n\",ans); &#125; return 0; return 0;&#125; 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#define maxn 1024#include&lt;set&gt;using namespace std;long long sum=0,f=1;set&lt;string&gt; sr[maxn];int main()&#123; string s1; cin&gt;&gt;s1; for(int i=0;i&lt;s1.length();i++) &#123; for(int j=1;j&lt;=s1.length();j++) &#123; string s2=s1.substr(i,j); if(s2.length()==j) sr[j-1].insert(s2); &#125; &#125; for(int i=0;i&lt;s1.length();i++) sum+=sr[i].size(); cout&lt;&lt;sum; /* set&lt;string&gt;::iterator int1=sr[0].begin(); set&lt;string&gt;::iterator int2=sr[0].end(); for(;int1!=int2;int1++) cout&lt;&lt;*int1&lt;&lt;\" \"; return 0; */&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"全排列","slug":"全排列","date":"2020-04-06T12:35:54.000Z","updated":"2020-04-25T10:22:04.004Z","comments":true,"path":"2020/04/06/全排列/","link":"","permalink":"http://yoursite.com/2020/04/06/全排列/","excerpt":"1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;long long sum=0,f=1;void judge(string s,int n)&#123; for(int i=0;i&lt;n;i++) &#123; int flag=1; for(int j=i+1;j&lt;n;j++) &#123; if(s[i]==s[j]) &#123; for(int k=j;k&lt;n-1;k++) s[k]=s[k+1]; n=n-1; j=j-1; flag++; &#125; &#125; f=f*flag; &#125;&#125;void per(string s,int n,int k)&#123; if(k&gt;=n) &#123; sum++; &#125; else for(int i=k;i&lt;n;i++) &#123; swap(s[i],s[k]); per(s,n,k+1); swap(s[i],s[k]); &#125;&#125;int main()&#123; string s1; cin&gt;&gt;s1; judge(s1,s1.length()); per(s1,s1.length(),0); cout&lt;&lt;sum;&#125;","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;long long sum=0,f=1;void judge(string s,int n)&#123; for(int i=0;i&lt;n;i++) &#123; int flag=1; for(int j=i+1;j&lt;n;j++) &#123; if(s[i]==s[j]) &#123; for(int k=j;k&lt;n-1;k++) s[k]=s[k+1]; n=n-1; j=j-1; flag++; &#125; &#125; f=f*flag; &#125;&#125;void per(string s,int n,int k)&#123; if(k&gt;=n) &#123; sum++; &#125; else for(int i=k;i&lt;n;i++) &#123; swap(s[i],s[k]); per(s,n,k+1); swap(s[i],s[k]); &#125;&#125;int main()&#123; string s1; cin&gt;&gt;s1; judge(s1,s1.length()); per(s1,s1.length(),0); cout&lt;&lt;sum;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-最大公约数最大公倍数","slug":"c-最大公约数最大公倍数","date":"2020-03-20T03:06:30.000Z","updated":"2020-04-25T10:24:42.012Z","comments":true,"path":"2020/03/20/c-最大公约数最大公倍数/","link":"","permalink":"http://yoursite.com/2020/03/20/c-最大公约数最大公倍数/","excerpt":"求最大公约数有三种方法一种是辗转相除法，另一种是相减法，还有穷举法。最大公倍数等于两数乘积/最大公约数。 辗转相除法有两种实现方法一种是递归法另一种是不使用递归递归： 123456int fun(int a,int b)&#123; if(a&lt;b) std::swap(a,b); return b==0?a:fun(b,a%b);&#125;","text":"求最大公约数有三种方法一种是辗转相除法，另一种是相减法，还有穷举法。最大公倍数等于两数乘积/最大公约数。 辗转相除法有两种实现方法一种是递归法另一种是不使用递归递归： 123456int fun(int a,int b)&#123; if(a&lt;b) std::swap(a,b); return b==0?a:fun(b,a%b);&#125; 非递归： 123456789101112int fun(int a,int b)&#123; int temp; if(b&gt;a) std::swap(a,b); while(b) &#123; temp=a%b; a=b; b=temp; &#125; return a;&#125; 相减法 123456789int fun(int a,int b)&#123; while(a!=b) &#123; if(a&gt;b) a=a-b; else b=b-a; &#125; return a;&#125; 穷举法首先保持第一个数为最大的值否则交换两个值，令i=m，开始递减，直到m和n同时除以i为0，此时输出最大公因数为max=i。 1234567891011int fun(int a,int b)&#123; if(a&lt;b) std::swap(a,b); for(int i=a;i&gt;1;i--) &#123; if(a%i==0&amp;&amp;b&amp;i==0) return a; &#125; &#125; 负数的二进制：将这个负数的相反数的二进制求出来并对每一位取反（这个过程叫取原码的反码），取反之后进行补码就行。","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-bits/stdc++.h","slug":"c-bits-stdc-h","date":"2020-03-20T02:21:28.000Z","updated":"2020-04-25T10:24:57.514Z","comments":true,"path":"2020/03/20/c-bits-stdc-h/","link":"","permalink":"http://yoursite.com/2020/03/20/c-bits-stdc-h/","excerpt":"","text":"#include &lt;bits/stdc++.h&gt;//这个头文件包含以下等等C++中包含的所有头文件: #include #include #include #include #include #include #include #include #include #include #include #include #include …….","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-getline的用法","slug":"c-getline的用法","date":"2020-03-17T22:46:31.000Z","updated":"2020-05-01T12:09:51.506Z","comments":true,"path":"2020/03/18/c-getline的用法/","link":"","permalink":"http://yoursite.com/2020/03/18/c-getline的用法/","excerpt":"在C++中本质上有两种getline函数：第一种：在头文件中，是iostream类的成员函数。第二种：在头文件中，是普通函数。 第一种istream&amp; getline (char* s, streamsize n );istream&amp; getline (char* s, streamsize n, char delim );作用是： 从istream中读取至多n个字符(包含结束标记符)保存在s对应的数组中。即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止，delim都不会被保存进s对应的数组中。","text":"在C++中本质上有两种getline函数：第一种：在头文件中，是iostream类的成员函数。第二种：在头文件中，是普通函数。 第一种istream&amp; getline (char* s, streamsize n );istream&amp; getline (char* s, streamsize n, char delim );作用是： 从istream中读取至多n个字符(包含结束标记符)保存在s对应的数组中。即使还没读够n个字符，如果遇到delim 或 字数达到限制，则读取终止，delim都不会被保存进s对应的数组中。 第二种stream&amp; getline (istream&amp; is, string&amp; str, char delim);istream&amp; getline (istream&amp;&amp; is, string&amp; str, char delim);istream&amp; getline (istream&amp; is, string&amp; str);istream&amp; getline (istream&amp;&amp; is, string&amp; str);用法和上第一种类似，但是读取的istream是作为参数is传进函数的。读取的字符串保存在string类型的str中。函数的变量：is ：表示一个输入流，例如 cin。str ：string类型的引用，用来存储输入流中的流信息。delim ：char类型的变量，所设置的截断字符；在不自定义设置的情况下，遇到’\\n’，则终止输入。另一种用法：用istringstream iss（string&amp; s）语句空格作为字符串分隔符再用getline (string&amp; iss, string&amp; str，’ ‘);表明不断读取s中的字符并存放在str中 举例： 1234567891011121314151617#include&lt;iostream&gt;iss#include&lt;sstream&gt;using namespace std;int main()&#123; string s; getline(cin,s);//输入一行数据包括空格 //当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（空格、制表符或换行符）。 //一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。 istringstream iss(s);//istringstream用吧空格作为字符串分隔符 string temp; while(getline(iss,temp,' ')) &#123; cout&lt;&lt;temp&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-回溯法模板与例题","slug":"c-回溯法模板与例题","date":"2020-03-17T09:03:18.000Z","updated":"2020-04-25T10:22:54.582Z","comments":true,"path":"2020/03/17/c-回溯法模板与例题/","link":"","permalink":"http://yoursite.com/2020/03/17/c-回溯法模板与例题/","excerpt":"模板1234567891011121314151617try(int i) &#123; if(i&gt;n) 输出结果; else &#123; for(j = 下界; j &lt;= 上界; j=j+1) // 枚举i所有可能的路径 &#123; if(fun(j)) // 满足限界函数和约束条件 &#123; a[i] = j; ... // 其他操作 try(i+1); 回溯前的清理工作（如a[i]置空值等）; &#125; &#125; &#125;","text":"模板1234567891011121314151617try(int i) &#123; if(i&gt;n) 输出结果; else &#123; for(j = 下界; j &lt;= 上界; j=j+1) // 枚举i所有可能的路径 &#123; if(fun(j)) // 满足限界函数和约束条件 &#123; a[i] = j; ... // 其他操作 try(i+1); 回溯前的清理工作（如a[i]置空值等）; &#125; &#125; &#125; 1234567891011121314151617181920public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); backtracking(n,k,1,list); return result; &#125; public void backtracking(int n,int k,int start,List&lt;Integer&gt;list)&#123; if(k&lt;0) return ; else if(k==0)&#123; result.add(new ArrayList(list)); &#125;else&#123; for(int i=start;i&lt;=n;i++)&#123; list.add(i); backtracking(n,k-1,i+1,list); list.remove(list.size()-1); &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-vector的基本应用","slug":"c-vector的基本应用","date":"2020-03-17T06:40:25.000Z","updated":"2021-01-14T07:47:32.417Z","comments":true,"path":"2020/03/17/c-vector的基本应用/","link":"","permalink":"http://yoursite.com/2020/03/17/c-vector的基本应用/","excerpt":"vector的创建vector q; vector的使用v1.push_back(p) 将数组p存放到v1中；v2.pop_back(q) 将数组q从v2中删除；v3。size（）大小判断；","text":"vector的创建vector q; vector的使用v1.push_back(p) 将数组p存放到v1中；v2.pop_back(q) 将数组q从v2中删除；v3。size（）大小判断； 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt; using namespace std;struct price&#123; int a,b,c;&#125;;vector&lt;price&gt; v1;int main()&#123; for(int i=0;i&lt;10;i++) &#123; price p=&#123;i,i*i,i*i*i&#125;; v1.push_back(p); &#125; for(int i=0;i&lt;v1.size();i++) &#123; cout&lt;&lt;v1[i].a&lt;&lt;\" \"&lt;&lt;v1[i].b&lt;&lt;\" \"&lt;&lt;v1[i].c&lt;&lt;endl; &#125;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-并查集","slug":"c-并查集","date":"2020-03-15T13:03:21.000Z","updated":"2020-04-25T10:21:18.171Z","comments":true,"path":"2020/03/15/c-并查集/","link":"","permalink":"http://yoursite.com/2020/03/15/c-并查集/","excerpt":"","text":"初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//初始化int fa[maxn];void init(int n)&#123; for(int i=0;i&lt;=n;i++) fa[i]=i;&#125;//查找父节点int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;// 合并void merge(int i,int j)&#123; fa[find(i)]=find(j);&#125;**例题**- 问题描述 w星球的一个种植园，被分成 m * n 个小格子（东西方向m行，南北方向n列）。每个格子里种了一株合根植物。 这种植物有个特点，它的根可能会沿着南北或东西方向伸展，从而与另一个格子的植物合成为一体。 如果我们告诉你哪些小格子间出现了连根现象，你能说出这个园中一共有多少株合根植物吗？- 输入格式 第一行，两个整数m，n，用空格分开，表示格子的行数、列数（1&lt;m,n&lt;1000）。 接下来一行，一个整数k，表示下面还有k行数据(0&lt;k&lt;100000) 接下来k行，第行两个整数a，b，表示编号为a的小格子和编号为b的小格子合根了。&lt;!--more--&gt; 格子的编号一行一行，从上到下，从左到右编号。 比如：5 * 4 的小格子，编号： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20- 样例输入5 4162 31 55 94 87 89 1010 1111 1210 1412 1614 1817 1815 1919 209 1313 17- 样例输出5**代码**```c++#include&lt;iostream&gt;#define Max 1000000using namespace std;//const int Max = 1000000;int fa[Max],n,m,k,temp=0;void init()//初始化 &#123; for(int i=1;i&lt;=n*m;i++)&#123; fa[i]=i; &#125; &#125;int find(int x)&#123; return fa[x]==x?x:fa[x]=find(fa[x]);&#125;void merge(int i,int j)&#123; fa[find(i)]=find(j);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; init(); cin&gt;&gt;k; for(int r=0;r&lt;k;r++) &#123; int i,j; cin&gt;&gt;i&gt;&gt;j; merge(i,j); &#125; for(int i=1;i&lt;=n*m;i++) &#123; if(fa[i]==i) temp++; &#125; cout&lt;&lt;temp;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-矩阵的扩散","slug":"c-矩阵的扩散","date":"2020-03-13T15:25:05.000Z","updated":"2020-04-25T10:23:19.792Z","comments":true,"path":"2020/03/13/c-矩阵的扩散/","link":"","permalink":"http://yoursite.com/2020/03/13/c-矩阵的扩散/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,m,k; cin&gt;&gt;n&gt;&gt;m; char array[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;array[i][j]; //储存数据0(n) int M=max(n,m); int I[M],J[M],a=0,b=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(array[i][j]=='g') &#123; I[a++]=i; J[b++]=j; &#125; //扩散 cin&gt;&gt;k; for(int i=0;i&lt;a;i++) &#123; for(int r=I[i]-k;r&lt;=I[i]+k;r++) for(int s=J[i]-k;s&lt;=J[i]+k;s++) &#123; if(r&gt;=0&amp;&amp;r&lt;n&amp;&amp;s&gt;=0&amp;&amp;s&lt;m) array[r][s]='g'; &#125; &#125; //输出 for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) cout&lt;&lt;array[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-整数转换为字符串","slug":"c-整数转换为字符串","date":"2020-03-13T09:18:44.000Z","updated":"2020-04-25T10:24:36.828Z","comments":true,"path":"2020/03/13/c-整数转换为字符串/","link":"","permalink":"http://yoursite.com/2020/03/13/c-整数转换为字符串/","excerpt":"1.使用sstreamm类整数转换为字符串 1234567891011121314151617#include&lt;iostream&gt;#include&lt;sstream&gt;using namespace std;void is2(int x,string &amp;s_basic) &#123; stringstream ss; ss&lt;&lt;x; ss&gt;&gt;s_basic;&#125;int main()&#123; string s1; int n=123456; is2(n,s1); cout&lt;&lt;s1[3]; return 0;&#125;","text":"1.使用sstreamm类整数转换为字符串 1234567891011121314151617#include&lt;iostream&gt;#include&lt;sstream&gt;using namespace std;void is2(int x,string &amp;s_basic) &#123; stringstream ss; ss&lt;&lt;x; ss&gt;&gt;s_basic;&#125;int main()&#123; string s1; int n=123456; is2(n,s1); cout&lt;&lt;s1[3]; return 0;&#125; 1.使用sstreamm类字符串转换为整数，但字符串存储的一定要是数字否则输出零 1234567891011121314151617#include&lt;iostream&gt;#include&lt;sstream&gt;using namespace std;void is2(int &amp;x,string s_basic) &#123; stringstream ss; ss&lt;&lt;s_basic; ss&gt;&gt;x;&#125;int main()&#123; string s1=\"1234456\"; int n; is2(n,s1); cout&lt;&lt;n; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-矩阵的快速幂算法","slug":"c-矩阵的快速幂算法","date":"2020-03-12T15:10:07.000Z","updated":"2020-04-25T10:24:28.686Z","comments":true,"path":"2020/03/12/c-矩阵的快速幂算法/","link":"","permalink":"http://yoursite.com/2020/03/12/c-矩阵的快速幂算法/","excerpt":"1.主要思想快速幂的算法12345678910111213int fastPower(int base, int exponent) &#123; int sum = 1; while (exponent != 0) &#123; if ((exponent &amp; 1) != 0) &#123; sum *= base; &#125; exponent = exponent &gt;&gt; 1; // 对指数进行移位 base *= base; // 让base的次幂以2的倍数增长 &#125; return sum;&#125;","text":"1.主要思想快速幂的算法12345678910111213int fastPower(int base, int exponent) &#123; int sum = 1; while (exponent != 0) &#123; if ((exponent &amp; 1) != 0) &#123; sum *= base; &#125; exponent = exponent &gt;&gt; 1; // 对指数进行移位 base *= base; // 让base的次幂以2的倍数增长 &#125; return sum;&#125; 代码说明： 对于(exponent &amp; 1) != 0语句如果exponent是奇数则exponent&amp;1等于1，否则如果exponent为偶数则exponent&amp;1等于0； 关键思想是用二进制来计算指数 2.衍生出矩阵的快速幂算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int Array[n][n],unit[n][n],temp[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;Array[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(i==j) unit[i][j]=1; else unit[i][j]=0; //计算 while(m!=0)&#123; if((m&amp;1)!=0) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; int sum=0;//标记 for(int k=0;k&lt;n;k++) &#123; sum+=unit[i][k]*Array[k][j]; &#125; temp[i][j]=sum; //利用temp暂时储存第一次计算结果 &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) unit[i][j]=temp[i][j]; &#125; m=m&gt;&gt;1; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; int sum=0;//标记 for(int k=0;k&lt;n;k++) &#123; sum+=Array[i][k]*Array[k][j]; &#125; temp[i][j]=sum; //利用temp暂时储存第一次计算结果 &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) Array[i][j]=temp[i][j];&#125;for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) cout&lt;&lt;unit[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-练习六huffuman","slug":"c-练习六huffuman","date":"2020-03-06T16:18:17.000Z","updated":"2020-04-25T10:28:13.302Z","comments":true,"path":"2020/03/07/c-练习六huffuman/","link":"","permalink":"http://yoursite.com/2020/03/07/c-练习六huffuman/","excerpt":"","text":"问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 代码： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define Max 100using namespace std;int main()&#123; int n,input[Max]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;input[i]; //进行运算 int sum=0; if(n&gt;=2) &#123; for(int i=0;i&lt;n-1;i++) &#123; sort(input,input+n-i); input[0]=input[0]+input[1]; sum+=input[0]; for(int k=1;k&lt;n-i-1;k++) &#123; input[k]=input[k+1]; &#125; &#125; //求和 cout&lt;&lt;sum; &#125; else cout&lt;&lt;input[0]; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"C-大数阶乘","slug":"C-大数阶乘","date":"2020-03-05T05:19:08.000Z","updated":"2020-04-25T10:22:26.385Z","comments":true,"path":"2020/03/05/C-大数阶乘/","link":"","permalink":"http://yoursite.com/2020/03/05/C-大数阶乘/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define Max 100000using namespace std;int num[Max],len;void Init()&#123; num[0]=1; len=1;&#125;int mult(int num[],int len,int n)//num为数据中的每一个数，len为数组长度 &#123; long long temp=0; for(int i=0;i&lt;len;++i) &#123; temp=temp+num[i]*n;//关键代码 num[i]=temp%10; temp=temp/10; &#125; while(temp)//最大的数temp每个取一位 &#123; num[len++]=temp%10; temp=temp/10; &#125; return len;&#125;int main()&#123; int n; Init();//初始化数据 cin&gt;&gt;n; for(int i=2;i&lt;=n;++i) len=mult(num,len,i);//len即长度不断更新 for(int i=len-1;i&gt;=0;i--) cout&lt;&lt;num[i]; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-进制转换","slug":"c-进制转换","date":"2020-03-02T12:45:26.000Z","updated":"2020-04-25T10:23:09.439Z","comments":true,"path":"2020/03/02/c-进制转换/","link":"","permalink":"http://yoursite.com/2020/03/02/c-进制转换/","excerpt":"进制转换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define Max 100000#define R 16#define Q 8#include&lt;string.h&gt;using namespace std;char T[Max],G[Max];int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; long long m=1,temp=0; cin&gt;&gt;T; //转化R为10进制 while(T[m]) &#123; m++;&#125; //判断T的长度 for(int i=0;i&lt;m;i++) &#123; if(T[i]&gt;='0'&amp;&amp;T[i]&lt;='9') &#123; temp=temp+(T[i]-'0')*pow(R,m-1-i); &#125; else &#123; temp=temp+(T[i]-'A'+10)*pow(R,m-i-1); &#125; &#125; //转化10为Q进制 int i=0; m=1; while(temp) &#123; G[i]=fmod(temp,Q)+'0'; temp=temp/Q; i++; &#125; while(G[m]) &#123; m++;&#125; //判断T的长度 int j=m-1; for(int i=0;i&lt;m/2;i++) &#123; swap(G[i],G[j]); j--; &#125; cout&lt;&lt;G; &#125; return 0;&#125; 不建议用来16进制转8进制，因数据过大，该算法有一定的缺陷。","text":"进制转换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define Max 100000#define R 16#define Q 8#include&lt;string.h&gt;using namespace std;char T[Max],G[Max];int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; long long m=1,temp=0; cin&gt;&gt;T; //转化R为10进制 while(T[m]) &#123; m++;&#125; //判断T的长度 for(int i=0;i&lt;m;i++) &#123; if(T[i]&gt;='0'&amp;&amp;T[i]&lt;='9') &#123; temp=temp+(T[i]-'0')*pow(R,m-1-i); &#125; else &#123; temp=temp+(T[i]-'A'+10)*pow(R,m-i-1); &#125; &#125; //转化10为Q进制 int i=0; m=1; while(temp) &#123; G[i]=fmod(temp,Q)+'0'; temp=temp/Q; i++; &#125; while(G[m]) &#123; m++;&#125; //判断T的长度 int j=m-1; for(int i=0;i&lt;m/2;i++) &#123; swap(G[i],G[j]); j--; &#125; cout&lt;&lt;G; &#125; return 0;&#125; 不建议用来16进制转8进制，因数据过大，该算法有一定的缺陷。 利用二进制转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt; #define Max 100000using namespace std;char T[10][Max],G[10][Max],W[10][Max];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;T[i]; for(int i=0;i&lt;n;i++) &#123; int m=1; while(T[i][m]) &#123;m++;&#125; //将T转化为2进制 switch(T[i][0]) &#123; case '1': G[i][0]='1'; break; case '2': G[i][0]='1'; G[i][1]='0';break; case '3': G[i][0]='1'; G[i][1]='1';break; case '4': G[i][0]='1'; G[i][1]='0'; G[i][2]='0';break; case '5': G[i][0]='1'; G[i][1]='0'; G[i][2]='1';break; case '6': G[i][0]='1'; G[i][1]='1'; G[i][2]='0';break; case '7': G[i][0]='1'; G[i][1]='1'; G[i][2]='1';break; case '8': G[i][0]='1'; G[i][1]='0'; G[i][2]='0'; G[i][3]='0';break; case '9': G[i][0]='1'; G[i][1]='0'; G[i][2]='0'; G[i][3]='1';break; case 'A': G[i][0]='1'; G[i][1]='0'; G[i][2]='1'; G[i][3]='0';break; case 'B': G[i][0]='1'; G[i][1]='0'; G[i][2]='1'; G[i][3]='1';break; case 'C': G[i][0]='1'; G[i][1]='1'; G[i][2]='0'; G[i][3]='0';break; case 'D': G[i][0]='1'; G[i][1]='1'; G[i][2]='0'; G[i][3]='1';break; case 'E': G[i][0]='1'; G[i][1]='1'; G[i][2]='1'; G[i][3]='0';break; case 'F': G[i][0]='1'; G[i][1]='1'; G[i][2]='1'; G[i][3]='1';break; default:cout&lt;&lt;\"有非16进制字符出现\";break; &#125; int n=1; while(G[i][n]) &#123;n++;&#125; for(int k=1;k&lt;m;k++) &#123; int j; j=k; switch(T[i][k]) &#123; case '0': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='0';break; case '1': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='1';break; case '2': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='0';break; case '3': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='1';break; case '4': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='0';break; case '5': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='1';break; case '6': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='0';break; case '7': G[i][4*j-4+n]='0'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='1';break; case '8': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='0';break; case '9': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='1';break; case 'A': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='0';break; case 'B': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='0'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='1';break; case 'C': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='0';break; case 'D': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='0'; G[i][4*j-1+n]='1';break; case 'E': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='0';break; case 'F': G[i][4*j-4+n]='1'; G[i][4*j-3+n]='1'; G[i][4*j-2+n]='1'; G[i][4*j-1+n]='1';break; default:cout&lt;&lt;\"有非16进制字符出现\";break; &#125; &#125; int temp=0; m=1; while(G[i][m]) &#123;m++;&#125; if(m%3==1) &#123;W[i][0]='1'; temp++;&#125; if(m%3==2) &#123;W[i][0]=(G[i][0]-'0')*2+(G[i][1]-'0')+'0'; temp++;&#125; for(int k=m%3;k&lt;m;k=k+3) W[i][temp++]=(G[i][k]-'0')*4+(G[i][k+1]-'0')*2+(G[i][k+2]-'0')+'0'; if(i==n-2) cout&lt;&lt;W[i]; else cout&lt;&lt;W[i]&lt;&lt;endl; &#125; return 0;&#125; 进制转换时忽略前导012345678910int flag=0;for(int i=0;i&lt;=s2.length()-3;i+=3)&#123; int num=4*(s2[i]-'0')+2*(s2[i+1]-'0')+(s2[i+2]-'0'); if(num) flag=1;//忽略前导0 if(flag) cout&lt;&lt;num;&#125;cout&lt;&lt;endl;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"C-为什么大数组要定义在main函数外","slug":"c-数组容量超出问题","date":"2020-03-02T01:47:38.000Z","updated":"2020-04-25T10:31:26.186Z","comments":true,"path":"2020/03/02/c-数组容量超出问题/","link":"","permalink":"http://yoursite.com/2020/03/02/c-数组容量超出问题/","excerpt":"","text":"全局变量在静态存储区分配内存，局部变量是在栈上分配内存空间的。（c语言程序在运行时会动态创建一个堆栈段，里面存放着调用栈，保存着函数的调用关系和局部变量。）如果数组太大，可能会造成栈溢出。全局变量在静态存储区内分配内存，而局部变量是在栈内分配内存空间的。C语言编写的程序会在运行期间创建一个栈堆段，用来保存函数的调用关系和局部变量。而在main函数内部定义大数组相当于在站内需要一个很大的空间，会造成栈的溢出。因此，当我们需要定义一个极大的数组时，最好在mian 函数外部定义这个大数组。","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"C-易错点","slug":"c-易错点","date":"2019-11-27T12:24:26.000Z","updated":"2020-04-25T10:29:29.620Z","comments":true,"path":"2019/11/27/c-易错点/","link":"","permalink":"http://yoursite.com/2019/11/27/c-易错点/","excerpt":"1. 易错点一a&lt;b&lt;c在c语言中的解释是，a&lt;b先会返回一个值，如果a&lt;b为真则返回1，为假返回0，然后再进行1&lt;c或0&lt;c的运算。 2. 易错点二若x和n都是int型变量，且x和n的初值都是6，则计算表达式x+=n++后，x的值为 12 ；n的值为：7 3. 易错点三设有定义：float a=2,b=4,h=3;以下C语言表达式中与代数式 的计算结果不相符的是（ B ）A）(a+b)h/2 B）(1/2)(a+b)h C）(a+b)h1/2 D）h/2(a+b)因为1/2在C语言中计算等于零。","text":"1. 易错点一a&lt;b&lt;c在c语言中的解释是，a&lt;b先会返回一个值，如果a&lt;b为真则返回1，为假返回0，然后再进行1&lt;c或0&lt;c的运算。 2. 易错点二若x和n都是int型变量，且x和n的初值都是6，则计算表达式x+=n++后，x的值为 12 ；n的值为：7 3. 易错点三设有定义：float a=2,b=4,h=3;以下C语言表达式中与代数式 的计算结果不相符的是（ B ）A）(a+b)h/2 B）(1/2)(a+b)h C）(a+b)h1/2 D）h/2(a+b)因为1/2在C语言中计算等于零。 4. 易错点四||运算找到第一个满足条件就结束。 #include &lt;stdio.h&gt;void main(){int i=1,j=1,k=2;if( (j++||k++)&amp;&amp;i++ ) j++成立就不会寻找下一个内容printf(“%d,%d,%d\\n”,i,j,k);}执行后的输出结果是（ C ）A）1,1,2 B）2,2,1 C）2,2,2 D）2,2,3 5. 易错点五","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"matlab-sum的相关操作","slug":"matlab-sum的相关操作","date":"2019-11-09T07:53:46.000Z","updated":"2019-11-09T08:14:04.981Z","comments":true,"path":"2019/11/09/matlab-sum的相关操作/","link":"","permalink":"http://yoursite.com/2019/11/09/matlab-sum的相关操作/","excerpt":"1. 题目","text":"1. 题目 2. 使用for循环进行解决123456789101112function f=ED(x,n)a=0;f=0;for i=1:n a=a+cos(x(i));endfor i=1:n b=n-a+i*(1-cos(x(i)))-sin(x(i)); f=f+b^2;endend 注意： for i=1:n 3. 使用sum进行解决代码： 12345function f=EDG(x,n)a=sum(cos(x));b=1:n;f=sum((n-a+b.*(1-cos(x))-sin(x)).^2);end 注意： 常数可以和向量相加相减； 常数与向量进行乘除操作时需要加(.)，例如.*和./等操作； 本题中的i是一个向量属于1：1：n； 4. 改进减少参数n的输入: 123456function f=EDG(x)n=length(x);a=sum(cos(x));b=1:n;f=sum((n-a+b.*(1-cos(x))-sin(x)).^2);end 注意： 主要是使用length求向量x的长度；","categories":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/categories/matlab/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://yoursite.com/tags/matlab/"}]},{"title":"C/C++变量定义","slug":"c-变量定义","date":"2019-11-07T14:30:10.000Z","updated":"2020-04-25T10:27:46.601Z","comments":true,"path":"2019/11/07/c-变量定义/","link":"","permalink":"http://yoursite.com/2019/11/07/c-变量定义/","excerpt":"整型变量整型变量一共具有四种类型： 整型(int) 4字节 长整型(long) 4字节 长长整型(long long) 8字节","text":"整型变量整型变量一共具有四种类型： 整型(int) 4字节 长整型(long) 4字节 长长整型(long long) 8字节 字符型变量-字符型(char) 1字节 浮点型 单精度浮点型(float) 4字节 双精度浮点型(double) 8字节 长双精度浮点型(long double) 16字节","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c- 链表","slug":"c-链表","date":"2019-11-05T14:02:31.000Z","updated":"2020-04-25T10:28:44.546Z","comments":true,"path":"2019/11/05/c-链表/","link":"","permalink":"http://yoursite.com/2019/11/05/c-链表/","excerpt":"1. 创建链表的结构体123456789#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;typedef int datatype;typedef struct node&#123; datatype data; struct node *next;&#125;linklist;linklist *p,*head;","text":"1. 创建链表的结构体123456789#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;typedef int datatype;typedef struct node&#123; datatype data; struct node *next;&#125;linklist;linklist *p,*head; 2. 删除、插入、查找、定位操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//创建链表头插法 输出结果为逆置的 linklist *createlist()&#123; char ch; int x; linklist *s,*head; head=NULL; //链表开始是为空 必须定义 ch=getchar(); while(ch!='*') &#123; scanf(\"%d\",&amp;x); s=(linklist*)malloc(sizeof(linklist));//保证s仅仅是一个节点 s-&gt;data=x; //书上源代码 s=malloc(sizeof(linklist)); s-&gt;next=head; head=s; ch=getchar(); &#125; return head; &#125;//创建链尾头插法 输出结果为顺序的 linklist *creatlist() &#123; char ch; //表示结束标志 int x; linklist *head,*r,*s; head=(linklist*)malloc(sizeof(linklist)); r=head;//主要是利用r进行操作 ch=getchar(); while(ch!='*') &#123; scanf(\"%d\",&amp;x); s=(linklist*)malloc(sizeof(linklist)); s-&gt;data=x; r-&gt;next=s; r=s; ch=getchar(); &#125; r-&gt;next=NULL;//一定要将 r-&gt;next置空否则会出现无限循环 return (head); &#125;//查找运算查找结点 linklist *lookpoint(linklist *head,int i)&#123; int j=0; linklist *p; p=head;//从头结点(不存数据在第一个结点)开始 把head的地址传给p while(p-&gt;next!=NULL&amp;&amp;j&lt;i) &#123; p=p-&gt;next; j++; &#125; if(i==j) return p; else return NULL;&#125; //查找运算，按值查找linklist *lookkey(linklist *head,int key)&#123; linklist *p; p=head-&gt;next;//从开始结点（存数据在第二个结点） 开始 while(p!=NULL) &#123; if(p-&gt;data!=key) p=p-&gt;next; else break; &#125; return p; &#125; //(后)插入运算，将新结点插入到*p结点之后 void insert(linklist *p,int x) &#123; linklist *s; s=(linklist *)malloc(sizeof(linklist)); //p=lookpoint(p,i); s-&gt;data=x; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; //查找与插入结合void INSERT(linklist *p,int i,int x) &#123; linklist *L; int j; j=i-1; L=lookpoint(p,j); insert(L,x); &#125;// (前)插入运算，将新结点插入到*p结点之前void beforeinser(linklist *p,int x)&#123; linklist *s; s=(linklist *)malloc(sizeof(linklist));//结点 s-&gt;data=p-&gt;data; s-&gt;next=p-&gt;next; p-&gt;data=x; p-&gt;next=s; &#125; //删去结点p的后继，首先用一个指针*r指向被删结点接着修改*p的指针域（next），最后释放结点*r void deleter(linklist *p) &#123; linklist *r; //指针 r=p-&gt;next; p-&gt;next=r-&gt;next; free(r);; &#125; //打印链表void print(linklist *head) //打印出链表head中各个结点的值&#123; linklist *p; p=head-&gt;next; while(p!=NULL) &#123; printf(\"%d \",p-&gt;data); p=p-&gt;next; &#125; printf(\"\\n\");&#125; 3.主函数设计12345678910111213141516171819int main()&#123; linklist *head,*p; //创建链表 head=creatlist(); p=head;print(head);//寻找结点并插入 //INSERT(head,5,2); head=lookpoint(head,2); insert(head,5);print(p);//删除结点head=p;head=lookpoint(head,4);deleter(head) ;print(p); return 0;&#125; 4. 测试结果","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c++练习五","slug":"c-练习五","date":"2019-11-04T04:51:41.000Z","updated":"2020-04-25T10:28:30.908Z","comments":true,"path":"2019/11/04/c-练习五/","link":"","permalink":"http://yoursite.com/2019/11/04/c-练习五/","excerpt":"1. POJ1028题目 DescriptionStandard web browsers contain features to move backward and forward among the pages recently visited. One way to implement these features is to use two stacks to keep track of the pages that can be reached by moving backward and forward. In this problem, you are asked to implement this.The following commands need to be supported:BACK: Push the current page on the top of the forward stack. Pop the page from the top of the backward stack, making it the new current page. If the backward stack is empty, the command is ignored.FORWARD: Push the current page on the top of the backward stack. Pop the page from the top of the forward stack, making it the new current page. If the forward stack is empty, the command is ignored.VISIT : Push the current page on the top of the backward stack, and make the URL specified the new current page. The forward stack is emptied.QUIT: Quit the browser.Assume that the browser initially loads the web page at the URL http://www.acm.org/","text":"1. POJ1028题目 DescriptionStandard web browsers contain features to move backward and forward among the pages recently visited. One way to implement these features is to use two stacks to keep track of the pages that can be reached by moving backward and forward. In this problem, you are asked to implement this.The following commands need to be supported:BACK: Push the current page on the top of the forward stack. Pop the page from the top of the backward stack, making it the new current page. If the backward stack is empty, the command is ignored.FORWARD: Push the current page on the top of the backward stack. Pop the page from the top of the forward stack, making it the new current page. If the forward stack is empty, the command is ignored.VISIT : Push the current page on the top of the backward stack, and make the URL specified the new current page. The forward stack is emptied.QUIT: Quit the browser.Assume that the browser initially loads the web page at the URL http://www.acm.org/ InputInput is a sequence of commands. The command keywords BACK, FORWARD, VISIT, and QUIT are all in uppercase. URLs have no whitespace and have at most 70 characters. You may assume that no problem instance requires more than 100 elements in each stack at any time. The end of input is indicated by the QUIT command. OutputFor each command other than QUIT, print the URL of the current page after the command is executed if the command is not ignored. Otherwise, print “Ignored”. The output for each command should be printed on its own line. No output is produced for the QUIT command. Sample InputVISIT http://acm.ashland.edu/VISIT http://acm.baylor.edu/acmicpc/BACKBACKBACKFORWARD VISIT http://www.ibm.com/BACKBACKFORWARDFORWARDFORWARDQUITSample Outputhttp://acm.ashland.edu/http://acm.baylor.edu/acmicpc/http://acm.ashland.edu/http://www.acm.org/Ignoredhttp://acm.ashland.edu/http://www.ibm.com/http://acm.ashland.edu/http://www.acm.org/http://acm.ashland.edu/http://www.ibm.com/Ignored 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;string&gt;#define MAX 1024using namespace std;int judgement(string str)&#123; string str1; if(str==\"BACK\") return 1; else if(str==\"FORWARD\") return 2; else if(str==\"VISIT\") return 3; else return 0;&#125; void web()&#123; string str1[MAX],str2[MAX],str[MAX],index,temp; int n=0,m=0,store=0; str1[0]=\"http://www.acm.org/\"; cin&gt;&gt;index; while(index!=\"QUIT\") &#123; if(judgement(index)==3) &#123; m=0; n++; cin&gt;&gt;index; str[store]=index; str1[n]=index; store++; &#125; if(judgement(index)==1) &#123; str2[m]=str1[n]; m++; n--; if(n&lt;0) //对于 str1数组溢出情况的处理 &#123; str[store]=\"Ignored\"; store++; m--; n++; str1[0]=\"http://www.acm.org/\"; &#125; else &#123; str[store]=str1[n]; store++; &#125; &#125; if(judgement(index)==2) &#123; n++; m--; if(m&lt;0)//对于 str2数组溢出情况的处理 &#123; m++; n--; str[store]=\"Ignored\"; store++; &#125; else &#123; str1[n]=str2[m]; str[store]=str1[n]; store++; &#125; &#125; cin&gt;&gt;index; &#125; for(int i=0;i&lt;store;i++) cout&lt;&lt;str[i]&lt;&lt;endl; &#125;int main()&#123; web();&#125; POJ1013使用枚举法：题目 DescriptionSally Jones has a dozen Voyageur silver dollars. However, only eleven of the coins are true silver dollars; one coin is counterfeit even though its color and size make it indistinguishable from the real silver dollars. The counterfeit coin has a different weight from the other coins but Sally does not know if it is heavier or lighter than the real coins.Happily, Sally has a friend who loans her a very accurate balance scale. The friend will permit Sally three weighings to find the counterfeit coin. For instance, if Sally weighs two coins against each other and the scales balance then she knows these two coins are true. Now if Sally weighsone of the true coins against a third coin and the scales do not balance then Sally knows the third coin is counterfeit and she can tell whether it is light or heavy depending on whether the balance on which it is placed goes up or down, respectively.By choosing her weighings carefully, Sally is able to ensure that she will find the counterfeit coin with exactly three weighings. InputThe first line of input is an integer n (n &gt; 0) specifying the number of cases to follow. Each case consists of three lines of input, one for each weighing. Sally has identified each of the coins with the letters A–L. Information on a weighing will be given by two strings of letters and then one of the words up&#39;&#39;,down’’, or ``even’’. The first string of letters will represent the coins on the left balance; the second string, the coins on the right balance. (Sally will always place the same number of coins on the right balance as on the left balance.) The word in the third position will tell whether the right side of the balance goes up, down, or remains even. OutputFor each case, the output will identify the counterfeit coin by its letter and tell whether it is heavy or light. The solution will always be uniquely determined. Sample Input1ABCD EFGH evenABCI EFJK upABIJ EFGH evenSample OutputK is the counterfeit coin and it is light. 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;char Left[3][7]; //天平左边硬币char Right[3][7]; //天平右边硬币char result[3][7]; //称量结果bool IsFake(char c,bool light);//light为真表示假设假币为轻，否则表示假设假币为重int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; for(int i = 0;i &lt; 3; ++i) cin &gt;&gt; Left[i] &gt;&gt; Right[i] &gt;&gt; result[i]; for(char c='A'; c&lt;='L';c++) &#123; if( IsFake(c,true) )//假设c这个硬币为假硬币而且它比真硬币轻 &#123; cout &lt;&lt; c &lt;&lt; \" is the counterfeit coin and it is light.\\n\"; break; &#125; else if( IsFake(c,false) )//假设c这个硬币为假硬币而且它比真硬币重 &#123; cout &lt;&lt; c &lt;&lt; \" is the counterfeit coin and it is heavy.\\n\"; break; &#125; &#125; &#125; return 0; &#125;bool IsFake(char c,bool light)//light 为真表示假设假币为轻，否则表示假设假币为重&#123; for(int i = 0;i &lt; 4; i++) &#123; char * pLeft,*pRight; //指向天平两边的字符串 if(light) &#123; pLeft = Left[i]; pRight = Right[i]; &#125; else &#123; pLeft = Right[i]; pRight = Left[i]; &#125; switch(result[i][0]) &#123; case 'u': if (strchr(pRight,c) == NULL) return false; break; case 'e': if(strchr(pLeft,c) || strchr(pRight,c)) return false; break; case 'd': if ( strchr(pLeft,c) == NULL) return false; break; &#125; &#125; return true;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-for循环里面递归的探究","slug":"c-for循环里面递归的探究","date":"2019-11-02T03:04:08.000Z","updated":"2020-04-25T10:25:06.838Z","comments":true,"path":"2019/11/02/c-for循环里面递归的探究/","link":"","permalink":"http://yoursite.com/2019/11/02/c-for循环里面递归的探究/","excerpt":"代码样例1234567891011121314151617181920#include &lt;stdio.h&gt;static int count = 0;void recur(int i, int n)&#123; count++; printf(\"B&gt;\"); for(i; i &lt;= n; i++) &#123; printf(\"I&gt;\"); recur(i + 1, n); printf(\"R&gt;\"); &#125;&#125;int main()&#123; int n=1; recur(0, n); printf(\" COUNT= %d\\n\", count); return 0;&#125;","text":"代码样例1234567891011121314151617181920#include &lt;stdio.h&gt;static int count = 0;void recur(int i, int n)&#123; count++; printf(\"B&gt;\"); for(i; i &lt;= n; i++) &#123; printf(\"I&gt;\"); recur(i + 1, n); printf(\"R&gt;\"); &#125;&#125;int main()&#123; int n=1; recur(0, n); printf(\" COUNT= %d\\n\", count); return 0;&#125; 说明n次的for循环执行的次数是n，n次的递归调用次数亦是n，两者合在一起理想的状态应该 n2次，但因为递归的特性，却大大增加了复杂度。1.n=1时程序的输出是： B&gt;I&gt;B&gt;I&gt;B&gt;R&gt;R&gt;I&gt;B&gt;R&gt; COUNT=4 2.即recur调用了4次，和我们预期的结果n2是相同的 3.n=2时，程序输出是：B&gt;I&gt;B&gt;I&gt;B&gt;I&gt;B&gt;R&gt;R&gt;I&gt;B&gt;R&gt;R&gt;I&gt;B&gt;I&gt;B&gt;R&gt;R&gt;I&gt;B&gt;R&gt; COUNT=8 4.这时候,recur调用次数是n2,接着我们再用不同的n测试，也验证了n2的正确性 原文链接：https://blog.csdn.net/mikayong/article/details/51706508","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c-algorithm基本库","slug":"c-algorithem基本库","date":"2019-10-30T12:07:18.000Z","updated":"2020-04-25T10:29:40.397Z","comments":true,"path":"2019/10/30/c-algorithem基本库/","link":"","permalink":"http://yoursite.com/2019/10/30/c-algorithem基本库/","excerpt":"algorithm常用函数1. sort函数排序代码及结果：","text":"algorithm常用函数1. sort函数排序代码及结果： 2.swap函数交换两个数代码及截图： 3.min,max函数求最大最小值代码及截图： 参考http://www.cplusplus.com/reference/algorithm/ 4.大小写字母转换在string型字符串中 将s1中的字符串改写成小写字母的字符串存在s2中： 1transform(s1.begin(),s1.end(),back_inserter(s2),::tolower); 将s3中的字符串改写成大写字母的字符串存在s4中： 1transform(s3.begin(),s3.end(),back_inserter(s4),::toupper);","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c-线性表","slug":"c-线性表","date":"2019-10-30T11:43:19.000Z","updated":"2020-04-25T10:29:20.641Z","comments":true,"path":"2019/10/30/c-线性表/","link":"","permalink":"http://yoursite.com/2019/10/30/c-线性表/","excerpt":"1. 创建线性表的结构体1234567891011#include&lt;stdio.h&gt;#define maxsize 1024 //线性表的最大长度 typedef int datatype;//typedef 为C语言的关键字，作用是为一种数据类型定义一个新的名字， //这种数据类型包括内部数据类型和自定义数据类型 //1. 创建结构体typedef struct&#123; datatype data[maxsize]; int last;&#125;sequenlist;//结构体名","text":"1. 创建线性表的结构体1234567891011#include&lt;stdio.h&gt;#define maxsize 1024 //线性表的最大长度 typedef int datatype;//typedef 为C语言的关键字，作用是为一种数据类型定义一个新的名字， //这种数据类型包括内部数据类型和自定义数据类型 //1. 创建结构体typedef struct&#123; datatype data[maxsize]; int last;&#125;sequenlist;//结构体名 2. 删除、转置、插入、去重、定位操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//2. 取节点 datatype get(sequenlist *L,int i)&#123; return (*L).data[i-1]; &#125; //3. 表的长度int length(sequenlist *L)&#123; return (*L).last+1;&#125; //4. 删除线性表L的第i个结点即删除下标为i-1的结点 int Delete(sequenlist *L,int i)&#123; int j; if(i&lt;1||i&gt;length(L)) &#123; printf(\"eror!\"); return 0; &#125; else &#123; for(j=i;j&lt;length(L);j++) (*L).data[j-1]=(*L).data[j]; (*L).last=(*L).last-1; &#125; return 1;&#125;//5.在线性表L的第i个位置插入一个值为x的新结点bool insert(sequenlist *L,int x,int i)&#123; int j; if(((*L).last)&gt;=maxsize-1) &#123; printf(\"overflow\"); return false; &#125; else if((i&lt;1)||(i&gt;(*L).last+1)) &#123; printf(\"error\"); return false; &#125; else &#123; for(j=(*L).last;j&gt;=i-1;j--) (*L).data[j+1]=(*L).data[j]; (*L).data[i-1]=x; (*L).last++; &#125; return true; &#125; //6. 定位int locate(sequenlist *L,int x)&#123; for(int i=0;i&lt;(*L).last+1;i++) &#123; if((*L).data[i]==x) return i+1; &#125; return 0;&#125; //6.清除表L中多余重复的结点void purge(sequenlist *L)&#123; int i=1,j,x,y; while(i&lt;length(L)) &#123; x=get(L,i); j=i+1; while(j&lt;length(L)) &#123; y=get(L,j); if(x==y) Delete(L,j); else j++; &#125; i++; &#125;&#125;//7. 将表中的数据逆置void reverse(sequenlist *L)&#123; int i=0,j=(*L).last,t=0; while(i&lt;=length(L)/2) &#123; t=(*L).data[i]; (*L).data[i]=(*L).data[j]; (*L).data[j]=t; i++; j--; &#125;&#125; //8. 打印顺序表void print(sequenlist *L)&#123; int i=0; while(i&lt;length(L)) &#123; printf(\"%d \",(*L).data[i]); i++; &#125; printf(\"\\n\"); &#125; 3.主函数设计1234567891011121314151617181920212223242526//主函数 int main()&#123; sequenlist sl=&#123;&#123;1,2,3,4,5,6,7,8,9,10&#125;,9&#125;;//直接给顺序表赋初值 sequenlist *L;/*定义一个指向顺序表类型的指针变量*/ L=&amp;sl; printf(\"original:\\n\"); print(L); printf(\"length:\\n\"); printf(\"%d\\n\",length(L));//长度 printf(\"reverse:\\n\"); reverse(L);//逆置 print(L); printf(\"delete position two:\\n\"); Delete(L,2); //删除 print(L); printf(\"inser position two and add data is eight:\\n\"); insert(L,8,2);//插入使其出现重复项 print(L); printf(\"purge:\\n\"); purge(L); print(L); printf(\"eight locate:\\n\"); printf(\"%d\",locate(L,8)); return 0;&#125; 4. 测试结果","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c练习四（有关字符串的操作）","slug":"c-练习四","date":"2019-10-27T11:55:04.000Z","updated":"2020-04-25T10:28:25.010Z","comments":true,"path":"2019/10/27/c-练习四/","link":"","permalink":"http://yoursite.com/2019/10/27/c-练习四/","excerpt":"1. 项目一问题 描述判断一个由a-z这26个字符组成的字符串中哪个字符出现的次数最多 输入第1行是测试数据的组数n，每组测试数据占1行，是一个由a-z这26个字符组成的字符串每组测试数据之间有一个空行，每行数据不超过1000个字符且非空 输出n行，每行输出对应一个输入。一行输出包括出现次数最多的字符和该字符出现的次数，中间是一个空格。如果有多个字符出现的次数相同且最多，那么输出ascii码最小的那一个字符 样例输入2abbcccadfadffasdf 样例输出c 3f 4","text":"1. 项目一问题 描述判断一个由a-z这26个字符组成的字符串中哪个字符出现的次数最多 输入第1行是测试数据的组数n，每组测试数据占1行，是一个由a-z这26个字符组成的字符串每组测试数据之间有一个空行，每行数据不超过1000个字符且非空 输出n行，每行输出对应一个输入。一行输出包括出现次数最多的字符和该字符出现的次数，中间是一个空格。如果有多个字符出现的次数相同且最多，那么输出ascii码最小的那一个字符 样例输入2abbcccadfadffasdf 样例输出c 3f 4 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 1000void max_count()&#123; int n; scanf(\"%d\",&amp;n); char str[MAX]; int st[MAX]; for(int i=0;i&lt;n;i++) &#123; scanf(\"%s\",str); //将a-z的ascll值转换为整数 for(size_t j=0;j&lt;strlen(str);j++) st[j]=str[j]-'a'; //利用整数数组找出相同的数据 int index=0,max=0;//索引 char flag; for(size_t i=0;i&lt;strlen(str);i++) &#123; index=1; for(size_t j=i+1;j&lt;strlen(str);j++) &#123; if(st[i]==st[j]) index++; &#125; if(index&gt;max) &#123; max=index; flag=st[i]+'a'; &#125; &#125; printf(\"%c %d\",flag,max); &#125; &#125;int main()&#123; max_count(); return 0;&#125; 2. 项目二题目给定两个由大小写字母和空格组成的字符串s1和s2，它们的长度都不超过100个字符、也可以长度为0.判断压缩掉空格、并忽略大小写后，这两个字符串是否相等。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 100void conversion(char str[MAX])&#123; for(size_t i=0;i&lt;strlen(str);i++) &#123; if(str[i]==' ') &#123; //char t;//索引 for(size_t j=i;j&lt;strlen(str)-1;j++) str[j]=str[j+1]; str[strlen(str)-1]='\\0'; //去掉最后一个字符 &#125; else if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]=str[i]+32; &#125;&#125;void equality()&#123; char str1[MAX],str2[MAX]; //scanf(\"%s%s\",str1,str2); 空格或行符结束 gets(str1);//持续读入直到找到换行符才停止 gets(str2); conversion(str1); conversion(str2); if(strcmp(str1,str2)==0) printf(\"correct\\n\"); else printf(\"error\\n\"); &#125;int main()&#123; equality(); return 0;&#125; 3. 项目三题目 给定两个字符串s和t，请判断s是否是t的子序列。即从t中删除一些字符，将剩余的字符连接起来，即可获得s。s和t都由ASCII码的数字和字母组成，且长度不超过100000。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 100000bool contain(char str1[MAX],char str2[MAX])//判断str1是否是str2的子序列 (对str2修改？)&#123; int flag=0; //判断str2中是否存在str1 for(size_t i=0;i&lt;strlen(str1);i++) &#123; index: for(size_t j=0;j&lt;strlen(str2);j++) &#123; if(str1[i]==str2[j]) //如果在str2[]中找到和str1[]相同的一个字符，同时将在str[2]找到的字符删除 以免出现错误 //例如str1含两个a，而str2含一个a，如果不删除str2中的a将会出现相等的情况 &#123; flag++; for(size_t k=j;k&lt;strlen(str2)-1;k++) str2[k]=str2[k+1]; str2[strlen(str2)-1]='\\0'; i++; goto index; &#125; &#125; &#125; //printf(\"%d %d\\n\",flag,strlen(str1)); if(flag==strlen(str1)) return true; return false; &#125; int main()&#123; char s[MAX],t[MAX]; scanf(\"%s%s\",s,t); if(contain(s,t)) printf(\"yes\\n\"); else printf(\"not\\n\"); return 0;&#125; 4. 项目四问题请编写一个函数，其功能是将输入的字符串反转过来。 示例: 输入：s = “hello” 返回：”olleh” 代码 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define MAX 10000void conversion(char str[MAX])&#123; //char str1[MAX]; int j=0; char index=' '; j=strlen(str)-1; for(size_t i=0;i&lt;strlen(str)/2;i++) &#123; index=str[i]; str[i]=str[j]; str[j]=index; j--; &#125; printf(\"%s\",str);&#125;int main()&#123; char str[MAX]; printf(\"s=\"); scanf(\"%s\",str); conversion(str); return 0;&#125; 5. 项目五问题给定一个 32 位有符号整数，将整数中的数字进行反转。 示例 输入: 123 输出: 321 输入: -123 输出: -321 输入: 120 输出: 21只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。 代码 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define MAX 1000int reverse(int x)&#123; long a; char str[MAX]; int i=0; while(x!=0) //整数转化为字符串 &#123; a=x%10; str[i]=a+'0'; i++; x=x/10; &#125; printf(\"%s\",str); if(x&lt;(-1)*pow(2,32)||x&gt;pow(2,32)-1) return 0;&#125;int main()&#123; int x; scanf(\"%d\",&amp;x); reverse(x); return 0;&#125; 6. 项目六题目 Description给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：1：两个字符串长度不等。比如Beijing和Hebei2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如Beijing和Beijing3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如beijing和BEIjing4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如Beijing和Nanjing编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 Input包括两行，每行都是一个字符串 Output仅有一个数字表示关系编号。 代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void consion(string &amp;str)//大写变小写 &#123; for(size_t i=0;i&lt;str.size();i++) &#123; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]=str[i]+32; &#125;&#125;int judge(string str1,string str2)&#123; if(str1.size()!=str2.size()) return 1; if(str1==str2) return 2; if(str1!=str2) &#123; consion(str1); consion(str2); if(str1==str2) return 3; else return 4; &#125;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;judge(a,b); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"对于递归求解N个元素的所有子集代码","slug":"c-疑问代码","date":"2019-10-27T11:33:09.000Z","updated":"2020-04-25T10:24:04.411Z","comments":true,"path":"2019/10/27/c-疑问代码/","link":"","permalink":"http://yoursite.com/2019/10/27/c-疑问代码/","excerpt":"双递归代码：","text":"双递归代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string.h&gt;#include &lt;iostream&gt;#define MAX 10000using namespace std;void build(char str[],int n)&#123; if(n==0)//控制输出 &#123; cout&lt;&lt;\"&#123;\"; for(int i=0;i&lt;strlen(str);++i) if(str[i]!=' ') &#123; cout&lt;&lt;str[i]; &#125; cout&lt;&lt;\"&#125;\"&lt;&lt;endl; &#125; else &#123; /*** 先递归 ***/ build(str,n-1);//当 n=0之后执行下一步； //cout&lt;&lt;n&lt;&lt;endl;测试 char newstr[5] = &#123;' '&#125;;//去掉就把该位置的元素置成空 /*** 还原之前的状态 ***/ strcpy(newstr,str); /*** 越来越少的元素 ***/ newstr[n-1]= ' '; /*** 再次递归 ***/ build(newstr,n-1); &#125;&#125;int main()&#123; char str[MAX]; int n; gets(str); scanf(\"%d\",&amp;n); build(str,n); return 0; &#125; 部分代码结果: 请求实现过程 参考 https://www.cnblogs.com/orangebook/p/3537408.html?utm_source=tuicool&amp;utm_medium=referral","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"c++string基本库","slug":"c-string基本库","date":"2019-10-26T01:03:26.000Z","updated":"2020-04-25T10:29:57.613Z","comments":true,"path":"2019/10/26/c-string基本库/","link":"","permalink":"http://yoursite.com/2019/10/26/c-string基本库/","excerpt":"1. strcmp函数strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。 2. strlen函数strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符’\\0’为止，然后返回计数器值(长度不包含’\\0’)。","text":"1. strcmp函数strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。 2. strlen函数strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符’\\0’为止，然后返回计数器值(长度不包含’\\0’)。 3. strcpy函数strcpy，即string copy（字符串复制）的缩写。strcpy是一种C语言的标准库函数，strcpy把含有’\\0’结束符的字符串复制到另一个地址空间，返回值的类型为char。strcpy(char dest, const char *src);参数：dest为目标字符串，src为原始字符串。 4. strcat函数合并字符串以及字符串二 5.strchr功能：查找字符串s中首次出现字符c的位置说明：返回首次出现c的位置的指针，如果s中不存在c则返回NULL。 字符串的基本应用123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; string str=\"1234\"; //字符串的查找 if(str.find('2')==string::npos)//如果2不在里面则为真 //if(str.rfind(\"4\")==3) //查找第三个位置是不是4,如果是的话返回真 cout&lt;&lt;\"yes\"; else cout&lt;&lt;\"no\"; //字符串的转置 string ans; for(int i=str.length()-1;i&gt;=0;i--) &#123; ans.insert(ans.end(),str[i]); &#125; cout&lt;&lt;ans; &#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"python-进程和线程","slug":"python-进程和线程","date":"2019-10-18T07:33:07.000Z","updated":"2019-10-27T12:54:00.783Z","comments":true,"path":"2019/10/18/python-进程和线程/","link":"","permalink":"http://yoursite.com/2019/10/18/python-进程和线程/","excerpt":"1. 进程和线程的解释说明 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。","text":"1. 进程和线程的解释说明 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 2. python中的多进程在Windows系统中可以使用multiprocessing模块的Process类来创建子进程，下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。不使用多进程： 使用多进程： emmmm jupyter中运行不了multiprocessing。 主要通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束 3. python的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"C++练习三（poj练习）","slug":"c-练习三","date":"2019-10-16T07:45:54.000Z","updated":"2020-04-25T10:28:18.778Z","comments":true,"path":"2019/10/16/c-练习三/","link":"","permalink":"http://yoursite.com/2019/10/16/c-练习三/","excerpt":"1. poj.org的1003题题目 DescriptionHow far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We’re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 + 1/3 = 5/6 card lengths. In general you can make n cards overhang by 1/2 + 1/3 + 1/4 + … + 1/(n + 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(n + 1). This is illustrated in the figure below.","text":"1. poj.org的1003题题目 DescriptionHow far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We’re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 + 1/3 = 5/6 card lengths. In general you can make n cards overhang by 1/2 + 1/3 + 1/4 + … + 1/(n + 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(n + 1). This is illustrated in the figure below. InputThe input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits. OutputFor each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples.Sample Input 1.003.710.045.190.00 Sample Output3 card(s)61 card(s)1 card(s)273 card(s) 代码 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt; using namespace std;int text(double a)&#123; double n=0,m=2; int index=0; while(n&lt;a) &#123; n=n+1/m; m=m+1; index=index+1; &#125; return index;&#125;void card()&#123; double a; int b[10],n=0; while(cin&gt;&gt;a) &#123; if(a==0) break; b[n]=text(a); n++; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;b[i]&lt;&lt;\" card(s)\"&lt;&lt;endl;&#125;int main()&#123; card();&#125; 2. poj.org的1005题题目： DescriptionFred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.After doing more research, Fred has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the X axis. Locations below the X axis are in the water. The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.) InputThe first line of input will be a positive integer indicating how many data sets will be included (N). Each of the next N lines will contain the X and Y Cartesian coordinates of the land Fred is considering. These will be floating point numbers measured in miles. The Y coordinate will be non-negative. (0,0) will not be given. OutputFor each data set, a single line of output should appear. This line should take the form of: “Property N: This property will begin eroding in year Z.” Where N is the data set (counting from 1), and Z is the first year (start from 1) this property will be within the semicircle AT THE END OF YEAR Z. Z must be an integer. After the last data set, this should print out “END OF OUTPUT.” Sample Input2 1.0 1.025.0 0.0 Sample OutputProperty 1: This property will begin eroding in year 1.Property 2: This property will begin eroding in year 20.END OF OUTPUT. 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cmath&gt;#define pi 3.1415962using namespace std;int radius(double a,double b)&#123; double r=0,R=0; int n=0; if(b&lt;0) cout&lt;&lt;\"error\"; r=sqrt(fabs(a*a+b*b)); while(R&lt;=r) &#123; n++; R=sqrt(fabs(2*(50*n)/pi)); &#125; return n;&#125;void erosion()&#123; double x,y; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;\"Property \"&lt;&lt;i+1&lt;&lt;\": This property will begin eroding in year \"&lt;&lt;radius(x,y)&lt;&lt;\".\"&lt;&lt;endl; &#125; cout&lt;&lt;\"END OF OUTPUT.\";&#125;int main()&#123; erosion(); return 0;&#125; 2. poj.org的1007题题目： DescriptionOne measure of unsortedness&#39;&#39; in a sequence is the number of pairs of entries that are out of order with respect to each other. For instance, in the letter sequenceDAABEC’’, this measure is 5, since D is greater than four letters to its right and E is greater than one letter to its right. This measure is called the number of inversions in the sequence. The sequence AACEDGG&#39;&#39; has only one inversion (E and D)---it is nearly sorted---while the sequenceZWQM’’ has 6 inversions (it is as unsorted as can be—exactly the reverse of sorted).You are responsible for cataloguing a sequence of DNA strings (sequences containing only the four letters A, C, G, and T). However, you want to catalog them, not in alphabetical order, but rather in order of sortedness&#39;&#39;, frommost sorted’’ to ``least sorted’’. All the strings are of the same length. InputThe first line contains two integers: a positive integer n (0 &lt; n &lt;= 50) giving the length of the strings; and a positive integer m (0 &lt; m &lt;= 100) giving the number of strings. These are followed by m lines, each containing a string of length n. OutputOutput the list of input strings, arranged from most sorted&#39;&#39; toleast sorted’’. Since two strings can be equally sorted, then output them according to the orginal order. Sample Input10 6AACATGAAGGTTTTGGCCAATTTGGCCAAAGATCAGATTTCCCGGGGGGAATCGATGCAT Sample OutputCCCGGGGGGAAACATGAAGGGATCAGATTTATCGATGCATTTTTGGCCAATTTGGCCAAA 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;string&gt;#define max 100using namespace std;void DNA_sorting()&#123; int n,m,sorte[max],value=0; char str[max][max],t[max]; cin&gt;&gt;m&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;str[i][j]; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; for(int k=j+1;k&lt;m;k++) &#123; if(str[i][j]&gt;str[i][k]) value++; &#125; &#125; sorte[i]=value; value=0; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; if(sorte[i]&gt;sorte[j]) &#123; for(int l=0;l&lt;m;l++) &#123; t[l]=str[i][l]; str[i][l]=str[j][l]; str[j][l]=t[l]; &#125; value=sorte[i]; sorte[i]=sorte[j]; sorte[j]=value; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) cout&lt;&lt;str[i][j]; cout&lt;&lt;endl; &#125; &#125; int main()&#123; DNA_sorting(); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"python-正则性表达式","slug":"python-字符串","date":"2019-10-15T12:36:55.000Z","updated":"2019-10-16T07:45:23.403Z","comments":true,"path":"2019/10/15/python-字符串/","link":"","permalink":"http://yoursite.com/2019/10/15/python-字符串/","excerpt":"正则性表达式在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式","text":"正则性表达式在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} | 分支 foo|bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?&nbsp;&lt;name&gt;exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 例题 在该例题中主要到[]、{m,n}、$ 其中的[]匹配来自字符集的任意单一字符,{6,20}匹配至少6次至多20次,$匹配字符串的结束","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-文件操作","slug":"python-文件操作","date":"2019-10-09T12:40:05.000Z","updated":"2019-10-09T13:31:53.805Z","comments":true,"path":"2019/10/09/python-文件操作/","link":"","permalink":"http://yoursite.com/2019/10/09/python-文件操作/","excerpt":"1. 文件的读取语句 操作模式 具体含义 &#39;r&#39; 读取 （默认） &#39;w&#39; 写入（会先截断之前的内容） &#39;x&#39; 写入，如果文件已经存在会产生异常 &#39;a&#39; 追加，将内容写入到已有文件的末尾 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新（既可以读又可以写）","text":"1. 文件的读取语句 操作模式 具体含义 &#39;r&#39; 读取 （默认） &#39;w&#39; 写入（会先截断之前的内容） &#39;x&#39; 写入，如果文件已经存在会产生异常 &#39;a&#39; 追加，将内容写入到已有文件的末尾 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新（既可以读又可以写） 2.测试文件的读取 注：读取文本文件时，需要在使用open函数时指定好带路径的文件名，然后通过encoding参数指定编码，如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败 文件读取异常操作 注可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源。 文件的逐行读取使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中。 文件的写入 读取二进制文件（图片）","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"flask的安装","slug":"flask的安装","date":"2019-10-09T11:00:11.000Z","updated":"2020-04-25T10:26:02.485Z","comments":true,"path":"2019/10/09/flask的安装/","link":"","permalink":"http://yoursite.com/2019/10/09/flask的安装/","excerpt":"1. 创建应用目录进入D盘在git命令下输入代码： $mkdir falsky 2.在Python 3中创建虚拟环境进入命令提示符输入命令 pip install python-virtualenv","text":"1. 创建应用目录进入D盘在git命令下输入代码： $mkdir falsky 2.在Python 3中创建虚拟环境进入命令提示符输入命令 pip install python-virtualenv 3.进入虚拟环境进入命令提示符在路径D:\\flasky\\venv\\Scripts输入activate如图所示： 4.安装flask在虚拟环境中安装flask，要确保vritualenv虚拟环境已经激活，然后执行命令 (venv) $ pip install flask 查看虚拟环境安装了那些包： (venv) $ pip freeze 5.检查flask是否正确安装在虚拟环境下进入python然后输入代码import flask如果没有看到错误提示，就表明成功安装。","categories":[{"name":"python-web","slug":"python-web","permalink":"http://yoursite.com/categories/python-web/"}],"tags":[{"name":"python-web","slug":"python-web","permalink":"http://yoursite.com/tags/python-web/"}]},{"title":"c++实现老鼠走迷宫","slug":"c-实现老鼠走迷宫","date":"2019-10-04T12:26:05.000Z","updated":"2020-04-25T10:28:50.414Z","comments":true,"path":"2019/10/04/c-实现老鼠走迷宫/","link":"","permalink":"http://yoursite.com/2019/10/04/c-实现老鼠走迷宫/","excerpt":"1. 明确功能目标 程序开始运行时显示一个迷宫地图，给定入口和出口，游戏的任务是使用键盘上的方向键操纵老鼠在规定的时间内走到出口处。内容给定入口和出口，随机生成一个可以走出去的迷宫。老鼠从入口位置出发，要求求出从迷宫入口到出口有无通路，若有通路则指出其中一条通路的路径，即输出找到通路的迷宫数组，其中通路上的“0”用另外一个数字8替换，同时打印出所走通路径上每一步的位置坐标及下一步的方向。要求 老鼠形象可辨认，可用键盘操纵老鼠上下左右移动； 迷宫的墙足够结实，老鼠不能穿墙而过； 正确检测结果，若老鼠在规定时间内走到出口处，提示成功，否则提示失败； 添加编辑迷宫功能，可修改当前迷宫，修改内容：墙变路、路变墙； 找出走出迷宫的所有路径，以及最短路径。利用序列化功能实现迷宫地图文件的存盘和读出等功能","text":"1. 明确功能目标 程序开始运行时显示一个迷宫地图，给定入口和出口，游戏的任务是使用键盘上的方向键操纵老鼠在规定的时间内走到出口处。内容给定入口和出口，随机生成一个可以走出去的迷宫。老鼠从入口位置出发，要求求出从迷宫入口到出口有无通路，若有通路则指出其中一条通路的路径，即输出找到通路的迷宫数组，其中通路上的“0”用另外一个数字8替换，同时打印出所走通路径上每一步的位置坐标及下一步的方向。要求 老鼠形象可辨认，可用键盘操纵老鼠上下左右移动； 迷宫的墙足够结实，老鼠不能穿墙而过； 正确检测结果，若老鼠在规定时间内走到出口处，提示成功，否则提示失败； 添加编辑迷宫功能，可修改当前迷宫，修改内容：墙变路、路变墙； 找出走出迷宫的所有路径，以及最短路径。利用序列化功能实现迷宫地图文件的存盘和读出等功能 2. 实现过程1）整个地图使用二维字符实现2）流程图 3.代码1) 老鼠走迷宫的类： 123456789101112131415161718192021class mouse_maze&#123; public: void initialize();//初始化随机生成一个走得出去的迷宫 int rand_int(int a, int b);//随机获取两组a到b的数据 void gameshow();//游戏地图显示 void gamemazeshow();//老鼠走迷宫的地图显示 int run();//老鼠运行 void storage();//迷宫储存到文件 void reading();//从文件中读取文件 void change(int n,int m);//修改地图 void gametime();//游戏计时 int judge(int i,int j);//判断是否有出口 public: char s[N][N];//定义地图，包括墙壁。 int success=0; int head=0; char key; int x=1,y=0; int x1,y1;&#125;; 2) 初始化随机生成一个走得出去的迷宫 1234567891011121314151617181920212223242526272829303132333435363738void mouse_maze::initialize()&#123; int i, j; int flag=0; //初始化地图上下墙壁 for (int i=0;i&lt;N;i++) &#123; s[0][i]='$'; s[N-1][i]='$'; &#125; //初始化地图左右墙壁并生成出口和人口 for(int j=1;j&lt;N-1;j++) &#123; if(j==1) &#123; s[j][0]='*'; s[j][N-1]='$'; &#125; else if(j==N-2) &#123; s[j][0]='$'; s[j][N-1]='8'; &#125; else &#123; s[j][0]='$'; s[j][N-1]='$'; &#125; &#125; //初始化地图 for(int i=1;i&lt;N-1;i++) for(int j=1;j&lt;N-1;j++) s[i][j]=rand_int(0,1)+'0'; while(judge(1,1)==0) &#123; for(int i=1;i&lt;N-1;i++) for(int j=1;j&lt;N-1;j++) s[i][j]=rand_int(0,1)+'0'; &#125; &#125; 3）判断从迷宫入口到出口有无通路 1234567891011121314151617181920int mouse_maze::judge(int i,int j)&#123; s[i][j]='8'; //最终出口 if(i==N-2&amp;&amp;j==N-2) success=1; //用递归法判断老鼠的走向 if(success!=1&amp;&amp;s[i][j+1]=='0') judge(i,j+1); if(success!=1&amp;&amp;s[i+1][j]=='0') judge(i+1,j); if(success!=1&amp;&amp;s[i][j-1]=='0') judge(i,j-1); if(success!=1&amp;&amp;s[i-1][j]=='0') judge(i-1,j); if(success!=1) s[i][j]='0'; return success;&#125; 4) 显示迷宫的全部内容 1234567891011121314void mouse_maze::gameshow()&#123; system(\"cls\"); // 清屏 int i, j; cout&lt;&lt;endl; for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;\"\\t\"; for(int j=0;j&lt;N;j++) cout&lt;&lt;s[i][j]; //if(i==0) cout&lt;&lt;\"\\t游戏计时：\"; cout&lt;&lt;endl; &#125; &#125; 5) 显示进行游戏时的迷宫内容 123456789101112131415161718192021222324void mouse_maze::gamemazeshow() &#123; //system(\"cls\"); // 清屏 int i, j; cout&lt;&lt;endl; for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;\"\\t\"; for(int j=0;j&lt;N;j++) &#123; if(s[i][j]=='1'||s[i][j]=='$') cout&lt;&lt;\"$\"; else if(s[i][j]=='*') cout&lt;&lt;\"*\"; else cout&lt;&lt;\" \"; &#125; if(i==0) &#123; cout&lt;&lt;\"\\t\\t游戏计时：\"; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl&lt;&lt;\"注：按w向上移动,按s向下移动,按a向左移动,按d向右移动\"&lt;&lt;endl;&#125; 6) 将迷宫存储到文件中和从文件读取迷宫 1234567891011121314151617181920212223void mouse_maze::reading()&#123; ifstream read(\"maze.txt\",ios::in); if(!read) &#123; cout&lt;&lt;\"family.txt文件不存在\"; system(\"pause\"); exit(0); &#125; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) read&gt;&gt;s[i][j];&#125;void mouse_maze::storage()&#123; ofstream output(\"maze.txt\", ios::out); for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) output&lt;&lt;s[i][j]&lt;&lt;\" \"; output&lt;&lt;endl; &#125; &#125; 7) 改变迷宫 1234567void mouse_maze::change(int n,int m)&#123; if(s[n-1][m-1]=='1') s[n-1][m-1]='0'; else if(s[n-1][m-1]=='0'||s[n-1][m-1]=='8') s[n-1][m-1]='1';&#125; 8) 游戏运行 123456789101112131415161718192021222324252627282930int mouse_maze::run()&#123; int flag=0; switch(getch()) &#123;//x=1,y=0 case 119:x1=x-1;y1=y ;break;//向上； case 115:x1=x+1;y1=y ;break;//向下； case 97:x1=x;y1=y-1 ;break;//向左； case 100:x1=x;y1=y+1 ;break;//向右； default:cout&lt;&lt;\"重新输入：\" ;break; &#125; if(s[N-2][N-1]=='*') &#123; flag=1; &#125; else if(s[x1][y1]=='0'||s[x1][y1]=='8') &#123; s[x][y]='0'; s[x1][y1]='*'; gamemazeshow(); x=x1; y=y1; &#125; else &#123; gamemazeshow(); getch(); &#125; return flag; &#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"python-图形用户界面","slug":"python-图形用户界面","date":"2019-10-04T11:42:20.000Z","updated":"2019-10-09T13:35:27.831Z","comments":true,"path":"2019/10/04/python-图形用户界面/","link":"","permalink":"http://yoursite.com/2019/10/04/python-图形用户界面/","excerpt":"图形用户界基于tkinter模块的GUIGUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。","text":"图形用户界基于tkinter模块的GUIGUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"C++练习二（poj练习）","slug":"c-练习二","date":"2019-09-30T05:05:42.000Z","updated":"2020-04-25T10:28:06.134Z","comments":true,"path":"2019/09/30/c-练习二/","link":"","permalink":"http://yoursite.com/2019/09/30/c-练习二/","excerpt":"1. 练习一:poj.org的1001题题目： DescriptionProblems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems. This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25. InputThe input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9.","text":"1. 练习一:poj.org的1001题题目： DescriptionProblems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems. This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 &lt; R &lt; 99.999 ) and n is an integer such that 0 &lt; n &lt;= 25. InputThe input will consist of a set of pairs of values for R and n. The R value will occupy columns 1 through 6, and the n value will be in columns 8 and 9. OutputThe output will consist of one line for each line of input giving the exact value of R^n. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don’t print the decimal point if the result is an integer. Sample Input 95.123 120.4321 205.1234 156.7592 998.999 101.0100 12 Sample Output548815620517731830194541.899025343415715973535967221869852721.0000000514855464107695612199451127676715483848176020072635120383542976301346240143992025569.928573701266488041146654993318703707511666295476720493953024 29448126.76412102161816443020690903717327667290429072743629540498.1075960194566517745610440100011.126825030131969720661201代码： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;sstream&gt; using namespace std;int main()&#123; string ch,s; double R,result; int n; while(cin&gt;&gt;R&gt;&gt;n) &#123; result=pow(R,n); if(result&lt;1) &#123; s=to_string(result); cout&lt;&lt;s.substr(1,s.length()-1)&lt;&lt;endl; &#125; else &#123; s=to_string(result); cout&lt;&lt;s&lt;&lt;endl; &#125; if((ch=cin.get())==\"EOF\") break; &#125; &#125; 参考 https://blog.csdn.net/happyjacob/article/details/81211713 https://blog.csdn.net/Imagirl1/article/details/82707672 问题：可能是使用了to_string导致精确度不够，而to_string不通用（只在增加c++11才能用），目前本人还不能解决。 2. 练习二的poj.org的1002题问题： DescriptionBusinesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino’s by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their ``three tens’’ number 3-10-10-10. The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows: A, B, and C map to 2D, E, and F map to 3G, H, and I map to 4J, K, and L map to 5M, N, and O map to 6P, R, and S map to 7T, U, and V map to 8W, X, and Y map to 9 There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010. Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.) Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number. InputThe input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters. OutputGenerate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line: No duplicates. Sample Input124873279ITS-EASY888-45673-10-10-10888-GLOPTUT-GLOP967-11-11310-GINOF101010888-1200 4-8-7-3-2-7-9-487-3279 Sample Output310-1010 2487-3279 4888-4567 3 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int String(string str)&#123; int value=0; for(size_t i=0;i&lt;str.size();i++) &#123; if((str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')||(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Y'&amp;&amp;str[i]!='Q')) &#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9') &#123; value*=10; value += str[i] - '0'; &#125; if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='P') &#123; value*=10; value+=((str[i]+1)/3)%10; &#125; if(str[i]&gt;='R'&amp;&amp;str[i]&lt;='Y') &#123; value*=10; value+=((str[i])/3)%10; &#125; &#125; &#125; return value; &#125;void order(int s[],int n)&#123; int t=0; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; if(s[i]&gt;s[j]) &#123; t=s[i]; s[i]=s[j]; s[j]=t; &#125; &#125; &#125;&#125; void print(int valu)&#123; char s[8]; for(int i=7;i&gt;=0;i--) &#123; if(i==3) s[i]='-'; else &#123; s[i]=valu%10+'0'; valu/=10; &#125; &#125; for(int i=0;i&lt;8;i++) cout&lt;&lt;s[i];&#125;int main()&#123; int n,store[100],flag=0; string s; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s; store[i]=String(s); &#125; order(store,n); for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; if(store[i]==store[j]) flag+=1; &#125; if(flag&gt;=1) &#123; print(store[i]); cout&lt;&lt;\" \"&lt;&lt;flag+1&lt;&lt;endl; for(int k=i+1;k&lt;n;k++) &#123; if(store[k]==store[i]) &#123; for(int y=k;y&lt;n;y++) store[y]=store[y+1]; n=n-1; k=k-1; &#125; &#125; flag=0; &#125; &#125; return 0; &#125; 应该大概可能解决了吧。运行时间有点长；","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"python-面对对象进阶","slug":"python-面对对象进阶","date":"2019-09-30T05:04:27.000Z","updated":"2019-09-30T10:05:20.314Z","comments":true,"path":"2019/09/30/python-面对对象进阶/","link":"","permalink":"http://yoursite.com/2019/09/30/python-面对对象进阶/","excerpt":"1. 面对对象进阶为了能够更好的使用面向对象编程思想进行程序开发，还需要对Python中的面向对象编程进行更为深入的了解。 2. @property装饰器我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示：","text":"1. 面对对象进阶为了能够更好的使用面向对象编程思想进行程序开发，还需要对Python中的面向对象编程进行更为深入的了解。 2. @property装饰器我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示： 3. slots魔法如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义slots变量来进行限定。需要注意的是slots的限定只对当前类的对象生效，对子类并不起任何作用。 4. 静态方法和类方法之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。获取当地时间： 1234from time import time,localtimedef now(clc): ctime=localtime(time()) return clc(ctime.tm_hour,ctime.tm_min,ctime.tm_sec) 5. 类之间的关系类和类之间的关系有三种：is-a、has-a和use-a关系。分别为继承、关联、依赖 6. 继承和多态 提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态。 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age &gt;= 18: print('%s正在观看美剧.' % self._name) else: print('%s只能观看《熊出没》.' % self._name)class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course))def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av()if __name__ == '__main__': main() 结果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-opencv","slug":"python-opencv","date":"2019-09-29T14:35:05.000Z","updated":"2019-10-27T12:26:07.680Z","comments":true,"path":"2019/09/29/python-opencv/","link":"","permalink":"http://yoursite.com/2019/09/29/python-opencv/","excerpt":"注意：opencv选择了默认路径下的可以使用以下方法解决 编写人脸识别的demo，从Github上面下载了haarcascade_frontalface_alt.xml放在了我的桌面，编译一直出问题，后来才发现在安装cv2这个模块的时候，会在你python安装路径下面生成”E:\\Python37\\Lib\\site-packages\\cv2\\data“，在这个路径下面就有haarcascade_frontalface_alt.xml只需要将：","text":"注意：opencv选择了默认路径下的可以使用以下方法解决 编写人脸识别的demo，从Github上面下载了haarcascade_frontalface_alt.xml放在了我的桌面，编译一直出问题，后来才发现在安装cv2这个模块的时候，会在你python安装路径下面生成”E:\\Python37\\Lib\\site-packages\\cv2\\data“，在这个路径下面就有haarcascade_frontalface_alt.xml只需要将： face_cascade = cv2.CascadeClassifier(‘./haarcascades/haarcascade_frontalface_default.xml’) 改为： face_cascade = cv2.CascadeClassifier(‘D:/Anaconda3/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml’) 若出现错误 可以在此电脑处搜索文件名，因为可能会出现文件多处出现的情况。 参考：https://blog.csdn.net/qq_42621977/article/details/89315619 照片中的人脸识别代码 123456789101112131415161718192021222324252627import cv2import numpy as np#1.静态图像中的人脸检测def StaticDetect(filename): #创建一个级联分类器 加载一个 .xml 分类器文件. 它既可以是Haar特征也可以是LBP特征的分类器. face_cascade = cv2.CascadeClassifier('./haarcascades/haarcascade_frontalface_default.xml') #加载图像 img = cv2.imread(filename) #转换为灰度图 gray_img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) #进行人脸检测，传入scaleFactor，minNegihbors，分别表示人脸检测过程中每次迭代时图像的压缩率以及 #每个人脸矩形保留近似数目的最小值 #返回人脸矩形数组 faces = face_cascade.detectMultiScale(gray_img,1.3,5) for (x,y,w,h) in faces: #在原图像上绘制矩形 img = cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2) cv2.namedWindow('Face Detected') cv2.imshow('Face Detected',img) cv2.waitKey(0) cv2.destroyAllWindows() if __name__=='__main__': filename = 'test.jpg' StaticDetect(filename) 结果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"C++练习一（poj练习）","slug":"c-练习一","date":"2019-09-29T06:23:39.000Z","updated":"2020-04-25T10:28:37.052Z","comments":true,"path":"2019/09/29/c-练习一/","link":"","permalink":"http://yoursite.com/2019/09/29/c-练习一/","excerpt":"1. 练习一poj.org的1000题题目： DescriptionCalculate a+b InputTwo integer a,b (0&lt;=a,b&lt;=10) OutputOutput a+b Sample Input1 2 Sample Output3","text":"1. 练习一poj.org的1000题题目： DescriptionCalculate a+b InputTwo integer a,b (0&lt;=a,b&lt;=10) OutputOutput a+b Sample Input1 2 Sample Output3 代码： 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; cout&lt;&lt;\"a(a&gt;=0): \"; cin&gt;&gt;a; if(a&lt;0)&#123; cout&lt;&lt;\"请重新输入： \"; cout&lt;&lt;\"a(a&gt;=0):\"; &#125; cout&lt;&lt;\"b(b&lt;=10): \"; cin&gt;&gt;b; if(b&gt;10)&#123; cout&lt;&lt;\"请重新输入： \"; cout&lt;&lt;\"b(b&lt;=10): \"; &#125; cout&lt;&lt;\"a+b=\"&lt;&lt;a+b; return 0; &#125; 2. 练习二题目： Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example:Input: 38Output: 2Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. 代码：第一种方法： 1234567891011121314151617181920212223242526//使用递归方法#include&lt;cmath&gt;using namespace std;class Solution &#123;public: int addDigits(int num) &#123; int index=0; while(num!=0) &#123; index+=num%10; num=num/10; &#125; num=index; if(num&gt;=10) return addDigits(num); else return num; &#125;&#125;;int main()&#123; Solution s; cout&lt;&lt;s.addDigits(120)&lt;&lt;endl;&#125; 第二种方法： 123456789101112131415161718192021222324252627//使用迭代法#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Solution &#123;public: int addDigits(int num) &#123; int index=0,flag=0; while(num&gt;=10) &#123; flag=num; while(flag!=0) &#123; index+=flag%10; flag=flag/10; &#125; num=index; index=0; &#125; return num; &#125;&#125;;int main()&#123; Solution s; cout&lt;&lt;s.addDigits(120)&lt;&lt;endl;&#125; 3. 练习三poj.org的1004题题目： DescriptionLarry graduated this year and finally has a job. He’s making a lot of money, but somehow never seems to have enough. Larry has decided that he needs to grab hold of his financial portfolio and solve his financing problems. The first step is to figure out what’s been going on with his money. Larry has his bank account statements and wants to see how much money he has. Help Larry by writing a program to take his closing balance from each of the past twelve months and calculate his average account balance. InputThe input will be twelve lines. Each line will contain the closing balance of his bank account for a particular month. Each number will be positive and displayed to the penny. No dollar sign will be included. OutputThe output will be a single number, the average (mean) of the closing balances for the twelve months. It will be rounded to the nearest penny, preceded immediately by a dollar sign, and followed by the end-of-line. There will be no other spaces or characters in the output. Sample Input 100.00489.1212454.121234.10823.05109.205.271542.25839.1883.991295.011.75 Sample Output$1581.42 代码： 12345678910111213#include&lt;iostream&gt;&gt;using namespace std;int main()&#123; float month,sum=0; for(int i=0;i&lt;12;i++) &#123; cin&gt;&gt;month; sum+=month; &#125; cout&lt;&lt;\"$\"&lt;&lt;sum/12; return 0; &#125; 4. 练习四poj.org的3980题题目： Description编写一个C函数mod(int n, int m),实现取模运算% Input输入包含多行数据每行数据是两个整数a, b (1 &lt;= a, b &lt;= 32767)数据以EOF结束 Output于输入的每一行输出a%b Sample Input5 3100 2 Sample Output20 代码： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int mod(int n,int m)&#123; return n-(n/m)*m;&#125;int main()&#123;int a,b;string ch; while(cin&gt;&gt;a&gt;&gt;b) &#123; cout&lt;&lt;mod(a,b)&lt;&lt;endl; if((ch=cin.get())==\"EOF\") break; &#125;&#125; 注意：取模与取余的区别： 取余运算在计算商值向0方向舍弃小数位 取模运算在计算商值向负无穷方向舍弃小数 取余，遵循尽可能让商大的原则 取模，遵循尽可能让商小的原则 从上面的区别可以总结出，取余（rem）和取模（mod）在被除数、除数同号时，结果是等同的，异号时会有区别，所以要特别注意异号的情况,经过测试，在C/C++, C#, JAVA, PHP这几门主流语言中，’%’运算符都是做取余运算，而在python中的’%’是做取模运算。在C/C++, C#, JAVA, PHP中a对b取模的公式为a-(a/b)*b。","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"markdown-基本语法","slug":"markdown-基本语法","date":"2019-09-28T12:05:25.000Z","updated":"2019-09-28T13:01:09.848Z","comments":true,"path":"2019/09/28/markdown-基本语法/","link":"","permalink":"http://yoursite.com/2019/09/28/markdown-基本语法/","excerpt":"1. 标题123# 一级标题## 二级标题### 三级标题 效果如下：","text":"1. 标题123# 一级标题## 二级标题### 三级标题 效果如下： 一级标题二级标题三级标题 2. 字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 效果如下： 加粗 斜体 加粗加斜体 删除线 3. 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…效果如下： 引用内容 引用内容 引用内容 4.分割线三个或者三个以上的 - 或者 * 都可以。或者&lt;hr&gt;例如： 12345-------*******&lt;hr&gt; 5. 图片 直接用图床工具就好 6.超链接语法 [超链接名](超链接地址 &quot;超链接title&quot;) 效果如下： 我的博客 7. 列表1）无序列表 用 - + * 任何一种都可以 123- 列表内容* 列表内容+ 列表内容 2）有序表 数字加点就可以 3）镶嵌结构 上一级和下一级之间敲三个空格即可 效果如下： 一级 二级 三级 一级 二级 三级 8. 表格语法： 12345678910表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果如下： 姓名 排名 李白 1 达明 2 9. 代码语法：单行代码：代码之间分别用一个反引号包起来多行代码：代码之间分别用三个反引号包起来，在第三个反引号后加c++或Java、python等 例如： 12345`单行代码` (```python 多行代码 ```) 注：不需要括号","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"python-练习二","slug":"python-练习二","date":"2019-09-28T11:51:56.000Z","updated":"2019-10-27T12:27:57.411Z","comments":true,"path":"2019/09/28/python-练习二/","link":"","permalink":"http://yoursite.com/2019/09/28/python-练习二/","excerpt":"练习1：定义一个类描述数字时钟","text":"练习1：定义一个类描述数字时钟 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from math import sqrtclass Point(object): def __init__(self, x=0, y=0): \"\"\"初始化方法 :param x: 横坐标 :param y: 纵坐标 \"\"\" self.x = x self.y = y def move_to(self, x, y): \"\"\"移动到指定位置 :param x: 新的横坐标 \"param y: 新的纵坐标 \"\"\" self.x = x self.y = y def move_by(self, dx, dy): \"\"\"移动指定的增量 :param dx: 横坐标的增量 \"param dy: 纵坐标的增量 \"\"\" self.x += dx self.y += dy def distance_to(self, other): \"\"\"计算与另一个点的距离 :param other: 另一个点 \"\"\" dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y))def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2))if __name__ == '__main__': main() 结果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-面对对象编程基础","slug":"python-面对对象编程基础","date":"2019-09-27T12:14:11.000Z","updated":"2019-09-30T05:03:04.890Z","comments":true,"path":"2019/09/27/python-面对对象编程基础/","link":"","permalink":"http://yoursite.com/2019/09/27/python-面对对象编程基础/","excerpt":"一、面对对象把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。简单的来说就是面向对象的三要素：封装、继承、多态","text":"一、面对对象把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。简单的来说就是面向对象的三要素：封装、继承、多态 二、类的定义在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法,定义好类后可以创建对象并给对象发消息。 三、访问可见性问题在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头。大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-练习一","slug":"python-练习一","date":"2019-09-27T04:53:18.000Z","updated":"2019-10-27T12:27:48.029Z","comments":true,"path":"2019/09/27/python-练习一/","link":"","permalink":"http://yoursite.com/2019/09/27/python-练习一/","excerpt":"练习一：在屏幕上显示跑马灯文字","text":"练习一：在屏幕上显示跑马灯文字 练习二：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。生成指定长度的验证码，由大小写英文字母和数字构成的随机验证码 练习三：计算指定的年月日是这一年的第几天注：公历闰年判定遵循的规律为: 四年一闰,百年不闰,四百年再闰。公历闰年的简单计算方法（符合以下条件之一的年份即为闰年）1.能被4整除而不能被100整除。2.能被100整除也能被400整除。 练习四：设计一个函数返回传入的列表中最大和第二大的元素的值。 练习五：打印杨辉三角形","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-web开发 (初步了解)","slug":"python-web开发1","date":"2019-09-26T14:10:44.000Z","updated":"2019-10-27T12:28:18.338Z","comments":true,"path":"2019/09/26/python-web开发1/","link":"","permalink":"http://yoursite.com/2019/09/26/python-web开发1/","excerpt":"什么是web开发呢，其实就是开发一个网站了。那开发网站需要用到哪些知识呢1、python基础，因为用python开发的，所以python指定要会，最起码你也得会条件判断，循环，函数，类这些知识；2、html、css的基础知识，因为要开发网站，网页都html和css写的，最起码这些知识你得会，就算不会写前端，开发不出来特别漂亮的页面，网站，最起码要能看懂html标签是；3、数据库基础知识，因为开发一个网站的话，数据存在哪里，就是在数据库里，那你最起码要会数据库的增删改查吧，要不然怎么存数据，取数据呢上面这些知识会的话，就基本上可以了，可以开发一个简单的小站就没有问题了，如果想开发比较大型的网站，业务逻辑比较复杂的，那就得用到其他的知识了，比如说redis、MQ等等。","text":"什么是web开发呢，其实就是开发一个网站了。那开发网站需要用到哪些知识呢1、python基础，因为用python开发的，所以python指定要会，最起码你也得会条件判断，循环，函数，类这些知识；2、html、css的基础知识，因为要开发网站，网页都html和css写的，最起码这些知识你得会，就算不会写前端，开发不出来特别漂亮的页面，网站，最起码要能看懂html标签是；3、数据库基础知识，因为开发一个网站的话，数据存在哪里，就是在数据库里，那你最起码要会数据库的增删改查吧，要不然怎么存数据，取数据呢上面这些知识会的话，就基本上可以了，可以开发一个简单的小站就没有问题了，如果想开发比较大型的网站，业务逻辑比较复杂的，那就得用到其他的知识了，比如说redis、MQ等等。 链接：https://blog.csdn.net/weixin_44266137/article/list/3?t=1&amp;","categories":[{"name":"python-web","slug":"python-web","permalink":"http://yoursite.com/categories/python-web/"}],"tags":[{"name":"python-web","slug":"python-web","permalink":"http://yoursite.com/tags/python-web/"}]},{"title":"python-字符串和常用数据结构","slug":"python-字符串和常用数据结构","date":"2019-09-26T13:19:58.000Z","updated":"2019-09-27T04:54:07.760Z","comments":true,"path":"2019/09/26/python-字符串和常用数据结构/","link":"","permalink":"http://yoursite.com/2019/09/26/python-字符串和常用数据结构/","excerpt":"字符串今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，一般记为：","text":"字符串今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，一般记为： 我们可以通过下面的代码来了解字符串的使用。 注：jupyter notebook 执行命令的时候报错：IndentationError: unexpected indent （意外的缩进）resolution：去掉空格除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。 使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作 通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。 对列表内容进行排序 使用列表的生成式语法来创建列表 ，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。 使用元组Python 的元组与列表类似，不同之处在于元组的元素不能修改。元组在创建时间和占用的空间上面都优于列表。我们使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间 使用集合Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。说明： Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符，我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&amp;运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-函数与模块的使用","slug":"python-函数与模块的使用","date":"2019-09-26T11:34:08.000Z","updated":"2019-09-26T13:28:26.222Z","comments":true,"path":"2019/09/26/python-函数与模块的使用/","link":"","permalink":"http://yoursite.com/2019/09/26/python-函数与模块的使用/","excerpt":"1.函数的定义 在Python中可以使用def关键字来定义函数，和c++的类类似，每个函数都有一个名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 例题： 求从m选取n的组合","text":"1.函数的定义 在Python中可以使用def关键字来定义函数，和c++的类类似，每个函数都有一个名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 例题： 求从m选取n的组合 说明： Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。 2.函数参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载， 例如： 例如： 注：在参数名前面的*表示args是一个可变参数，即在调用add函数时可以传入0个或多个参数 3. 用模块管理函数对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。例如： 显然他输出的是最后一个函数。解决办法：在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，如下图所示：module1.py module2.py test.py 4. name需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“main”。\\","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"项目开发构想","slug":"项目开发构想","date":"2019-09-25T14:27:41.000Z","updated":"2019-10-27T12:18:54.537Z","comments":true,"path":"2019/09/25/项目开发构想/","link":"","permalink":"http://yoursite.com/2019/09/25/项目开发构想/","excerpt":"项目构想现在有很多大学生面对大学生活很迷茫，不知道自己要干什么，根据这种情况，设计一个软件，以学校为大单位，以专业为小单位将学生在大学各个阶段可以参加的比赛进行分类汇总，以便学生参考。 项目目标大目标： 利用大数据分类汇总所有学校各院各专业的比赛信息小目标： 把桂电的比赛信息汇总出来","text":"项目构想现在有很多大学生面对大学生活很迷茫，不知道自己要干什么，根据这种情况，设计一个软件，以学校为大单位，以专业为小单位将学生在大学各个阶段可以参加的比赛进行分类汇总，以便学生参考。 项目目标大目标： 利用大数据分类汇总所有学校各院各专业的比赛信息小目标： 把桂电的比赛信息汇总出来 软件开发过程表：https://wenku.baidu.com/view/d25593dd5727a5e9856a61f9.html","categories":[{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/categories/项目开发/"}],"tags":[{"name":"项目开发","slug":"项目开发","permalink":"http://yoursite.com/tags/项目开发/"}]},{"title":"python-循环结构","slug":"python-循环结构","date":"2019-09-25T12:34:19.000Z","updated":"2019-09-26T11:56:08.993Z","comments":true,"path":"2019/09/25/python-循环结构/","link":"","permalink":"http://yoursite.com/2019/09/25/python-循环结构/","excerpt":"介绍在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 1. for-in循环如果明确的知道循环执行的次数或者是要对一个容器进行迭代，那么推荐使用for-in循环，例如求1到100的和:","text":"介绍在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 1. for-in循环如果明确的知道循环执行的次数或者是要对一个容器进行迭代，那么推荐使用for-in循环，例如求1到100的和: 输出九九乘法表： 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如：range(101)可以产生一个0到100的整数序列。range(1, 100)可以产生一个1到99的整数序列。range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 2. while循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。例如： 上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环 continue可以用来放弃本次循环后续的代码直接让循环进入下一轮。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python-分支结构","slug":"python-分支结构","date":"2019-09-25T12:04:33.000Z","updated":"2019-09-25T13:03:29.404Z","comments":true,"path":"2019/09/25/python-分支结构/","link":"","permalink":"http://yoursite.com/2019/09/25/python-分支结构/","excerpt":"1. if语句的使用1） 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名.注：和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。","text":"1. if语句的使用1） 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名.注：和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 2） 分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构， 2. 练习1） 分段函数求值 2）掷骰子决定做什么事情","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"设置U盘为第一启动项","slug":"设置U盘为第一启动项","date":"2019-09-25T09:29:41.000Z","updated":"2019-09-25T13:10:27.220Z","comments":true,"path":"2019/09/25/设置U盘为第一启动项/","link":"","permalink":"http://yoursite.com/2019/09/25/设置U盘为第一启动项/","excerpt":"如果在刷机过程中电脑出现重启错误怎么办 先试试强制关机后按F12看看能不能进入刷机U盘的界面 去bois设置U盘为第一启动项 1） 那我电脑为例进入bois的快捷键时F2.示例图：","text":"如果在刷机过程中电脑出现重启错误怎么办 先试试强制关机后按F12看看能不能进入刷机U盘的界面 去bois设置U盘为第一启动项 1） 那我电脑为例进入bois的快捷键时F2.示例图： 2） 去启动那一项设置，将U盘设置为优先级。 示例图： 3） 保存并退出，插入装机U盘便能进入到刷机界面。 示例图：","categories":[{"name":"刷机教程","slug":"刷机教程","permalink":"http://yoursite.com/categories/刷机教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"python-变量","slug":"python-变量","date":"2019-09-24T10:14:23.000Z","updated":"2019-09-27T02:17:05.480Z","comments":true,"path":"2019/09/24/python-变量/","link":"","permalink":"http://yoursite.com/2019/09/24/python-变量/","excerpt":"1. 变量命名规则1）硬性规则：变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。大小写敏感（大写的a和小写的A是两个不同的变量）。不要跟关键字（有特殊含义的单词）和系统保留字（如函数、模块等的名字）冲突。2）PEP 8要求：用小写字母拼写，多个单词用下划线连接。受保护的实例属性用单个下划线开头。私有的实例属性用两个下划线开头。","text":"1. 变量命名规则1）硬性规则：变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。大小写敏感（大写的a和小写的A是两个不同的变量）。不要跟关键字（有特殊含义的单词）和系统保留字（如函数、模块等的名字）冲突。2）PEP 8要求：用小写字母拼写，多个单词用下划线连接。受保护的实例属性用单个下划线开头。私有的实例属性用两个下划线开头。 2. 运算符注： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 3. 变量类型转换12345int()：将一个数值或字符串转换成整数，可以指定进制。float()：将一个字符串转换成浮点数。str()：将指定的对象转换成字符串形式，可以指定编码。chr()：将整数转换成该编码对应的字符串（一个字符）。ord()：将字符串（一个字符）转换成对应的编码（整数）。 4.练习1）基本运算 2）用type检查类型 3）将华氏温度转换为摄氏温度 4）输入圆的半径计算计算周长 5）输入年份判断是不是闰年。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"linux基本操作","slug":"linux基本操作","date":"2019-09-24T08:12:43.000Z","updated":"2019-09-24T11:29:27.106Z","comments":true,"path":"2019/09/24/linux基本操作/","link":"","permalink":"http://yoursite.com/2019/09/24/linux基本操作/","excerpt":"cd命令这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如： 123456cd /home 进入 '/ home' 目录' cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录","text":"cd命令这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如： 123456cd /home 进入 '/ home' 目录' cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 time命令该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如 12time ./process time ps aux 安装命令123456789101112131415161718192021yum install #全部安装yum install #安装指定的软件yum groupinsall #安装程序组#更新和升级yum update #全部更新yum update #更新指定程序包yum check-update #检查可更新的程序yum upgrade #升级指定程序包yum groupupdate #升级程序组#查找和显示yum list #显示所有已安装和可以安装的程序包yum list #显示指定程序包的安装情况yum info #显示程序包信息yum groupinfo #显示程序组信息#删除命令yum remove #删除程序包yum groupremove #删除程序组yum deplist #查看程序包的依赖情况#清除缓存yum clean packages #清除缓存目录下的软件包yum clean headers #清除缓存目录下的heades","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"win10自带虚拟机Hyper-V","slug":"win10自带虚拟机Hyper-V","date":"2019-09-23T09:03:18.000Z","updated":"2019-09-24T11:29:45.344Z","comments":true,"path":"2019/09/23/win10自带虚拟机Hyper-V/","link":"","permalink":"http://yoursite.com/2019/09/23/win10自带虚拟机Hyper-V/","excerpt":"教你如何使用win10自带虚拟机Hyper-V 按win+pause break快速打开控制面板的系统和安全中的系统，点击控制面板","text":"教你如何使用win10自带虚拟机Hyper-V 按win+pause break快速打开控制面板的系统和安全中的系统，点击控制面板 在控制面版中，打开程序组件，选择程序与功能。点击启动或关闭windows功能。 找到Hyper-V，打勾（注意win10家庭版时没有Hyper-V） 勾选后，点击立即重启 开机后找到Hyper-V，打开程序 虚拟机网络配置 打开Hyper-V，在右侧操作列表中点击“虚拟交换机管理”，打开虚拟交换机管理器 选择“新建虚拟网络交换机”，在虚拟交换机类型列表中选择“外部”，点击“创建虚拟交换机”，创建一个虚拟交换机，输入虚拟交换机的名称和说明，为虚拟交换机选择一个网络适配器（即物理网卡），点击“确定”。 等待应用更改 在Hyper-V管理器中，选择虚拟机，点击右侧操作列表中的“设置”，修改虚拟机配置。 在虚拟机设置界面，点击“网络适配器”，选择虚拟交换机，点击确定，这样就配置好了虚拟机的网络连接。这样就完成里虚拟机的网络配置了； 开始创建虚拟机了 下载虚拟机需要的镜像 推荐win10镜像链接：https://msdn.itellyou.cn/ 推荐Linux链接：https://ubuntu.com/download/desktop/thank-you?country=CN&amp;version=18.04.3&amp;architecture=amd64#download 将下载成功的镜像放在电脑上的一个文件夹中以备后用。 开始创建1）点击新建虚拟机 2）设置你的虚拟机的名称 3）指定代数，我选择的是第一代，继续选择下一步 4）网络配置，选择我们刚刚设置的网络名称 5）从我们的文件夹中选择镜像 6）后续就是下一步，完成。示意图： 7）这里显示已经创建好了，然后右键选择启动该虚拟机(有点小慢)。启动之后右键选择连接开始自动安装系统，注意选择语言，否则安装之后是英文，如果对英文有点感冒的话，这里就修改下，要不然安装好之后有需要在设置里修改。 安排： 选择语言点击install ubuntu，之后就是下一步、下一步。 说明：1.因为是虚拟机所以可以清空虚拟U盘里的东西，这样对你现有的电脑文件没有影响的 2. 如果重启的时候出现错误记得关闭虚拟机，然后在开启。 参考： https://baijiahao.baidu.com/s?id=1607835632188281786&amp;wfr=spider&amp;for=pc https://jingyan.baidu.com/article/a681b0de6109253b18434635.html https://jingyan.baidu.com/article/e9fb46e129349d7520f76648.html","categories":[{"name":"Hyper-v","slug":"Hyper-v","permalink":"http://yoursite.com/categories/Hyper-v/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"初识python","slug":"初识python","date":"2019-09-23T08:43:11.000Z","updated":"2019-09-24T11:04:15.076Z","comments":true,"path":"2019/09/23/初识python/","link":"","permalink":"http://yoursite.com/2019/09/23/初识python/","excerpt":"Python的优缺点Python的优点很多，简单的可以总结为以下几点。简单和明确，做一件事只有一种方法。学习曲线低，跟其他很多语言相比，Python更容易上手。开放源代码，拥有强大的社区和生态圈。解释型语言，天生具有平台可移植性。支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。Python的缺点主要集中在以下几点。执行效率稍低，因此计算密集型任务可以由C/C++编写。代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被淡化。在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。","text":"Python的优缺点Python的优点很多，简单的可以总结为以下几点。简单和明确，做一件事只有一种方法。学习曲线低，跟其他很多语言相比，Python更容易上手。开放源代码，拥有强大的社区和生态圈。解释型语言，天生具有平台可移植性。支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。Python的缺点主要集中在以下几点。执行效率稍低，因此计算密集型任务可以由C/C++编写。代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被淡化。在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 Python的应用领域目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位.本人主要感兴趣的有web开发和数据挖掘。 Linux环境下安装python3.xLinux环境自带了Python 3.x版本，在linux系统下: 代码中的注释注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。单行注释 （以#和空格开头的部分）多行注释 （三个引号开头，三个引号结尾）-（！import）示例： 注：该处使用的时jupyter notebook工具 练习 import this听说这是”python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。 学习使用turtle在屏幕上绘制图形。trutle英语翻译为海龟、人名：特特尔，理解：python绘图就像海龟在海中绘制美丽的图像。哈哈！1） turtle.setup() 函数用于启动一个图形窗口，它有四个参数，turtle.setup(width,height,startx,starty)，分别是：启动窗口的宽度和高度，表示窗口启动时，窗口左上角在屏幕中的坐标位置。向左为横坐标，向下为纵坐标。2） turtle.pensize()函数表示运动轨迹的宽度。它包含一个输入参数，即多少像素。3） turtle.pencolor()函数表示运动轨迹的颜色。它包含一个输入参数，即想要的颜色。4） turtle.seth()函数表示启动时运动的方向。它包含一个输入参数，是角度值。5） turtle.circle()函数表示绘制的图形为圆形，它包含两个参数，rad描述轨迹半径的位置，angle表示沿着圆形爬行的弧度值。6） turtle.fd()函数也可以用turtle.forward()表示，表示向前直线移动，它有一个参数表示移动的距离。主要是参考他人代码理解一波。示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from turtle import * def HSB2RGB(hues): hues = hues * 3.59 #100转成359范围 rgb=[0.0,0.0,0.0] i = int(hues/60)%6 f = hues/60 -i if i == 0: rgb[0] = 1; rgb[1] = f; rgb[2] = 0 elif i == 1: rgb[0] = 1-f; rgb[1] = 1; rgb[2] = 0 elif i == 2: rgb[0] = 0; rgb[1] = 1; rgb[2] = f elif i == 3: rgb[0] = 0; rgb[1] = 1-f; rgb[2] = 1 elif i == 4: rgb[0] = f; rgb[1] = 0; rgb[2] = 1 elif i == 5: rgb[0] = 1; rgb[1] = 0; rgb[2] = 1-f return rgb def rainbow(): hues = 0.0 color(1,0,0) #绘制彩虹 hideturtle() speed(100) pensize(3) penup() goto(-400,-300) pendown() right(110) for i in range (100): circle(1000) right(0.13) hues = hues + 1 rgb = HSB2RGB(hues) color(rgb[0],rgb[1],rgb[2]) penup() def main(): setup(800, 600, 0, 0) bgcolor((0.8, 0.8, 1.0)) tracer(False) rainbow() #输出文字 tracer(False) goto(100,-100) pendown() color(\"red\") write(\"菜鸟一号\",align=\"center\", font=(\"Script MT Bold\", 80, \"bold\")) tracer(True) mainloop() if __name__ == \"__main__\": main() 运行结果：","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Excel","slug":"Excel","date":"2019-09-23T06:25:34.000Z","updated":"2019-10-27T12:21:57.672Z","comments":true,"path":"2019/09/23/Excel/","link":"","permalink":"http://yoursite.com/2019/09/23/Excel/","excerpt":"Excel 10大常用公式1） 逻辑判断2） 复杂条件逻辑判断3） 汇总求和4） 复杂条件汇总求和5） 查找引用6） 复杂条件查找引用7） 四舍五入8） 文本截取9） 条件计数10）平均值和极值统计","text":"Excel 10大常用公式1） 逻辑判断2） 复杂条件逻辑判断3） 汇总求和4） 复杂条件汇总求和5） 查找引用6） 复杂条件查找引用7） 四舍五入8） 文本截取9） 条件计数10）平均值和极值统计 1. 逻辑判断IF语句： 2. 复杂条件逻辑判断IF语句的复杂版本 3. 汇总求和SUM函数： 效果如下： 4. 复杂条件汇总求和sumifs函数： 效果如下： 5. 查找引用VLOOKUP函数： 效果如下： 6. 复杂条件查找引用INDEX函数、MATCH函数 7. 四舍五入ROUND函数 8. 文本截取LEFT函数、RIGHT函数、MID函数 9. 条件计数COUNTIF函数 10. 平均值和极值统计AVERAGE函数：求平均值MAX函数：求最大值MIN函数：求最小值 参考 https://www.sohu.com/a/210341793_695443","categories":[{"name":"办公软件","slug":"办公软件","permalink":"http://yoursite.com/categories/办公软件/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"http://yoursite.com/tags/Excel/"}]},{"title":"ppt","slug":"ppt操作","date":"2019-09-23T06:24:59.000Z","updated":"2019-09-24T11:30:36.315Z","comments":true,"path":"2019/09/23/ppt操作/","link":"","permalink":"http://yoursite.com/2019/09/23/ppt操作/","excerpt":"ppt中将图片设置为高150px，宽100px。PX=pixel=像素在高度那块输入150像素，宽度输入100像素。注意不能输入px。 如何修改PPT中左下方状态栏的主题名称网上有很多很好的PPT，可惜一般作者都加了名字和主题，现在我们就来说说如何修改PPT中左下方状态栏的主题名称。","text":"ppt中将图片设置为高150px，宽100px。PX=pixel=像素在高度那块输入150像素，宽度输入100像素。注意不能输入px。 如何修改PPT中左下方状态栏的主题名称网上有很多很好的PPT，可惜一般作者都加了名字和主题，现在我们就来说说如何修改PPT中左下方状态栏的主题名称。 如下图所示： 在《视图》中点击《幻灯片母版》界面。选择第一张幻灯片。然后在点击左上角的重命名。记得重命名后要保存退出后再打开PPT。（！import）","categories":[{"name":"办公软件","slug":"办公软件","permalink":"http://yoursite.com/categories/办公软件/"}],"tags":[{"name":"ppt","slug":"ppt","permalink":"http://yoursite.com/tags/ppt/"}]},{"title":"电脑手工杀毒","slug":"电脑手工杀毒","date":"2019-09-23T01:52:18.000Z","updated":"2019-09-24T11:27:57.853Z","comments":true,"path":"2019/09/23/电脑手工杀毒/","link":"","permalink":"http://yoursite.com/2019/09/23/电脑手工杀毒/","excerpt":"常规杀灭进程法 有的进程在进程选项中无法删除，这时可以打开注册表编辑器（在“开始→运行”中键入regedit），找到1HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun 下面的键，将可疑的选项删除。 还可以通过系统的“管理工具”里面的“服务”查看目前的全部进程。这里重点要看服务中启动选项为“自动”的那部分进程，检查它们的名字、路径以及登录账户、服务属性的“恢复“里面有没有重启计算机的选项（有些机器不断属性的重新启动的秘密就在这里）。一旦发现可疑的名字需要马上禁止此进程的运行。","text":"常规杀灭进程法 有的进程在进程选项中无法删除，这时可以打开注册表编辑器（在“开始→运行”中键入regedit），找到1HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun 下面的键，将可疑的选项删除。 还可以通过系统的“管理工具”里面的“服务”查看目前的全部进程。这里重点要看服务中启动选项为“自动”的那部分进程，检查它们的名字、路径以及登录账户、服务属性的“恢复“里面有没有重启计算机的选项（有些机器不断属性的重新启动的秘密就在这里）。一旦发现可疑的名字需要马上禁止此进程的运行。 删除病毒程序而要彻底删除这些程序进程可以用下面的办法： 打开注册表编辑器,展开分支 1HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun 在右侧窗格中显示的就是本机安装的服务项，如果要删除某项服务，只要删除注册表中相关键值即可。 除了上面两种方法，我们还可以先查看这个进程文件所在的路径和名称。重启系统，按F8键进入安全模式，然后在安全模式下删除这个程序。 这里，笔者编写了容易被大家认出来的非法进程服务（系统进程）举例说明：HELLO-WORLD SERVICE ，我们可以轻松地在进程列表和“服务”中找到它。根据上面的方法，我们可以把这个进程杀掉或禁用。","categories":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/categories/computer/"}],"tags":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/tags/computer/"}]},{"title":"Computer-English-one","slug":"Computer-English-one","date":"2019-09-22T13:13:08.000Z","updated":"2019-09-24T11:29:04.285Z","comments":true,"path":"2019/09/22/Computer-English-one/","link":"","permalink":"http://yoursite.com/2019/09/22/Computer-English-one/","excerpt":"基础篇关于电脑组成部分的英语单词中央处理器： CPU主板： motherboard内存： disk硬盘： hard disk闪存盘/U盘： flash disk光盘： CD-compact disk","text":"基础篇关于电脑组成部分的英语单词中央处理器： CPU主板： motherboard内存： disk硬盘： hard disk闪存盘/U盘： flash disk光盘： CD-compact disk 驱动器： driver显示器： display / monitor触屏器： touch screen打印器： printer扬声器： speaker鼠标： mouse键盘： keyboad输入/输出设备： I/O device外部设备： peripheral主机： mainframe电缆： cable","categories":[{"name":"conmput_English","slug":"conmput-English","permalink":"http://yoursite.com/categories/conmput-English/"}],"tags":[{"name":"conmput English","slug":"conmput-English","permalink":"http://yoursite.com/tags/conmput-English/"}]},{"title":"win10部分有趣的命令提示符","slug":"cmd-命令提示符1","date":"2019-09-22T12:19:42.000Z","updated":"2019-10-27T12:26:43.015Z","comments":true,"path":"2019/09/22/cmd-命令提示符1/","link":"","permalink":"http://yoursite.com/2019/09/22/cmd-命令提示符1/","excerpt":"1）arp -a 获取IP地址，MAC地址解释：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。","text":"1）arp -a 获取IP地址，MAC地址解释：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。 2）arp -d* 命令用于清空arp缓存表。第一次运行： 第二次运行： 3）arp -s 网关IP，网关MAC，命令是将网关IP地址与相应的MAC地址进行静态绑定: 4） cleanmgr 垃圾整理: 5）compmgmt.msc 计算机管理: 6) calc 启动计算器: 7）mmc 打开控制台 8) logoff 注销（尝试的话记得保存文件） 9）osk 屏幕键盘 10）winver 检查系统信息 注：先写十个记一下，后续在操作其他内容。","categories":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/categories/computer/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"三种打开命令提示符的方法","slug":"两种打开命令提示符的方法","date":"2019-09-22T11:40:48.000Z","updated":"2019-09-24T11:28:21.065Z","comments":true,"path":"2019/09/22/两种打开命令提示符的方法/","link":"","permalink":"http://yoursite.com/2019/09/22/两种打开命令提示符的方法/","excerpt":"1.介绍命令提示符即cmd.exe，是一个32位的命令行程序，微软Win系统基于Win10上的命令解释程序，类似于微软的DOS操作系统. 2.打开方法1） 在运行窗口输入“cmd”可以使用管理员身份来打开命令提示符2） 按组合快捷键“win+ R”打开运行，输入命令：【cmd】，点击“确定”3） 鼠标右击桌面。 新建文本文档，可随意命名。 输入 cmd 点击“保存”。 修改文件后缀为bat。 打开文本运行命令提示符。","text":"1.介绍命令提示符即cmd.exe，是一个32位的命令行程序，微软Win系统基于Win10上的命令解释程序，类似于微软的DOS操作系统. 2.打开方法1） 在运行窗口输入“cmd”可以使用管理员身份来打开命令提示符2） 按组合快捷键“win+ R”打开运行，输入命令：【cmd】，点击“确定”3） 鼠标右击桌面。 新建文本文档，可随意命名。 输入 cmd 点击“保存”。 修改文件后缀为bat。 打开文本运行命令提示符。","categories":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/categories/computer/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"Chrome浏览器F12介绍","slug":"Chrome浏览器F12介绍","date":"2019-09-21T05:08:32.000Z","updated":"2019-09-24T11:28:57.563Z","comments":true,"path":"2019/09/21/Chrome浏览器F12介绍/","link":"","permalink":"http://yoursite.com/2019/09/21/Chrome浏览器F12介绍/","excerpt":"1. 可以直接修改页面元素选择页面上元素，右键“检查”，会打开开发者工具窗口，显示当前选择元素的源代码，可以双击进行修改。如果要修改的东西比较多，可以折叠元素并单击选择，再右键选择编辑为 HTML修改","text":"1. 可以直接修改页面元素选择页面上元素，右键“检查”，会打开开发者工具窗口，显示当前选择元素的源代码，可以双击进行修改。如果要修改的东西比较多，可以折叠元素并单击选择，再右键选择编辑为 HTML修改 2. 快速查找并定位文件查看源代码，鼠标移到开发工具窗口，按ctrl+p，输入链接地址的前几个字母，会自动联想显示所有符合条件的地址，点击打开即可。（有时第一次打开是空白内容，可再点击一次链接）打开之后，如果是js内容，就可以直接在上面打断点调试，另外可以点击内容框的左下角大括号图标“{ }”(pretty print)，对代码进行排版美化 3. 在修改别人写的网页时需要查找网页某处代码源代码 例如：","categories":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/categories/computer/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"计算机快捷键","slug":"计算机常用小知识点","date":"2019-09-21T04:47:04.000Z","updated":"2019-09-24T11:28:05.862Z","comments":true,"path":"2019/09/21/计算机常用小知识点/","link":"","permalink":"http://yoursite.com/2019/09/21/计算机常用小知识点/","excerpt":"1. 任务管理器快捷键方法一：同时按住电脑键盘上的“Shift+Ctrl+Esc”组合键，即可直接打开任务管理器。方法二：同时按住电脑键盘上的“Alt+Ctrl+Del”组合键，然后选择“任务管理器”，也可顺利打开。 2. 在浏览器显示全屏按住电脑键盘上的F11即浏览器显示全屏，再一次退出全屏。","text":"1. 任务管理器快捷键方法一：同时按住电脑键盘上的“Shift+Ctrl+Esc”组合键，即可直接打开任务管理器。方法二：同时按住电脑键盘上的“Alt+Ctrl+Del”组合键，然后选择“任务管理器”，也可顺利打开。 2. 在浏览器显示全屏按住电脑键盘上的F11即浏览器显示全屏，再一次退出全屏。 3. 不常用但及其有用的Ctrl组合键个人认为下面几种在写代码时很有用哦。 123ctrl+f 查找 #importctrl+g 定位 ctrl+h 替换 还有一些一般人不常用的: 1234ctrl+W 关闭当前窗口ctrl +esc 打开开始菜单ctrl+Y 恢复ctrl+H 历史 其他的什么ctrl+c的就不讲了 3. 删除DEL 删除光标后的字符BACKSPRCE 删除光标前的字符 4. CTRL+SHFT键盘中文、英文、大写字母交换 5. 空格空格键 空一个空格TAB 一般等于 8 个空格的长度，当它的前面有单词的时候，和单词长度加起来刚好能被 8 整除","categories":[{"name":"computer","slug":"computer","permalink":"http://yoursite.com/categories/computer/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"Anaconda环境中OpenCV库的安装及编程","slug":"Anaconda环境中OpenCV库的安装及编程","date":"2019-09-21T04:31:41.000Z","updated":"2019-09-24T11:04:00.835Z","comments":true,"path":"2019/09/21/Anaconda环境中OpenCV库的安装及编程/","link":"","permalink":"http://yoursite.com/2019/09/21/Anaconda环境中OpenCV库的安装及编程/","excerpt":"1. OpenCV的安装下面提示两种方法的安装 方法一：Anaconda 下使用 conda 安装 opencv：如果输入 conda install -c menpo opencv ，安装的版本是 v2.4.11；如果输入 conda install -c menpo opencv3 ，安装的版本是 v3.1.0 ；注：命令行启动的时候，需要右键-选择管理员权限。安装过程如下：","text":"1. OpenCV的安装下面提示两种方法的安装 方法一：Anaconda 下使用 conda 安装 opencv：如果输入 conda install -c menpo opencv ，安装的版本是 v2.4.11；如果输入 conda install -c menpo opencv3 ，安装的版本是 v3.1.0 ；注：命令行启动的时候，需要右键-选择管理员权限。安装过程如下： 安装完成后：执行以下命令可查看是否成功安装openCV 3 该方法很多新的python系统不支持这样运行。如果用了方法一安装不了可以尝试下面的方法。 方法二：直接安装最新版本的opencvAnaconda 下使用 conda 安装 opencv：直接输入：install python-opencv```123456789101112131415161718安装过程如下：![](https://cdn.jsdelivr.net/gh/upsilverfox/turoot/pic20190921124252.png)#### 1. OpenCV的编程1) 写图像文件```pythonimport cv2import numpy as npimg = np.zeros((3, 3), dtype = np.uint8) # 通过二维NumPy数组来简单创建一个黑色的正方形图像print(img) # 在控制台打印该图像print(img.shape) # 通过shape属性来查看图像的结构，返回行和列，如果有一个以上的通道，还会返回通道数img = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR) # 利用cv2.cvtColor函数将该图像转换成BGR格式print(img)print(img.shape)cv2.namedWindow(&quot;Image&quot;) # 显示该图像cv2.imshow(&quot;Image&quot;, img)cv2.waitKey (0) 2)读图像文件","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"hexo-next-Pisces主题的颜色配置","slug":"hexo-next主题的颜色配置","date":"2019-09-20T11:14:35.000Z","updated":"2019-09-24T11:27:09.069Z","comments":true,"path":"2019/09/20/hexo-next主题的颜色配置/","link":"","permalink":"http://yoursite.com/2019/09/20/hexo-next主题的颜色配置/","excerpt":"1.左上侧背景颜色在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces_layout.styl 里修改background的内容颜色可参考:RCG颜色对照表","text":"1.左上侧背景颜色在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces_layout.styl 里修改background的内容颜色可参考:RCG颜色对照表 2.文章部分的背景颜色可在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces_layout.styl 中修改 3.左下侧背景颜色可在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces_sidebar.styl 中作相应修改 4. 左侧上标签的底色可在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces\\menu.styl 中作相应修改： 5. 文章部分的文字颜色可在 D:\\博客\\themes\\next\\source\\css_schemes\\Pisces_layout.styl 中添加： 1color：white 如图： 6. 左上侧有标签部分文字在D:\\博客\\themes\\next\\source\\css_schemes\\Pisces\\menu.styl处需要添加： 1color: white 7. 左下侧部分文字在D:\\博客\\themes\\next\\source\\css_custom_custom.styl里添加: 1234//侧边颜色#sidebar &#123; p,span,a &#123;color: red&#125;&#125; red表示所变的颜色 8. 底部字体颜色在 D:\\博客\\themes\\next\\source\\css_custom_custom.sty 里添加 12//底部颜色.footer-inner &#123;color: white&#125; 9. 总体背景颜色在 D:\\博客\\themes\\next\\source\\css_custom_custom.styl 里添加 12345678//Custom styles.body &#123; background-image:url(https://cdn.jsdelivr.net/gh/upsilverfox/turoot/pic1.jpg);#填入照片链接 background-repeat: no-repeat;#不重复 background-attachment:fixed;#不移动 background-position:50% 50%;#照片位置 background-size: 100% 100%;#照片大小 &#125; 10. 左下侧标签栏的背景颜色在 D:\\博客\\themes\\next\\source\\css_custom_custom.styl 添加： 1234567#sidebar &#123; background:url(https://cdn.jsdelivr.net/gh/upsilverfox/turoot/pic20190920232339.png); background-size: cover; background-position:center; background-repeat:no-repeat; p,span,a &#123;color: black;&#125;&#125; 参考文献 https://blog.csdn.net/weixin_40837922/article/details/88047241 http://tool.oschina.net/commons?type=3 （RCG颜色对照表）","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"python-jupyter的设置","slug":"python-jupyter","date":"2019-09-20T07:45:02.000Z","updated":"2019-10-27T12:20:55.509Z","comments":true,"path":"2019/09/20/python-jupyter/","link":"","permalink":"http://yoursite.com/2019/09/20/python-jupyter/","excerpt":"1. 为jupyter设置默认浏览器jupyter 打开后无法直接跳转到浏览器解决方案1、首先打开Anoconda Prompt，输入命令 jupyter notebook –generate-config，系统会自动产生一个名为jupyter_notebook_config.py的文件，并且Anoconda Prompt窗口中会给出文件的路径。2、打开jupyter_notebook_config.py，在文件最后添加以下代码","text":"1. 为jupyter设置默认浏览器jupyter 打开后无法直接跳转到浏览器解决方案1、首先打开Anoconda Prompt，输入命令 jupyter notebook –generate-config，系统会自动产生一个名为jupyter_notebook_config.py的文件，并且Anoconda Prompt窗口中会给出文件的路径。2、打开jupyter_notebook_config.py，在文件最后添加以下代码 1234# c.NotebookApp.browser = ''import webbrowserwebbrowser.register('chrome',None,webbrowser.GenericBrowser(u'C:\\ProgramFiles(x86)\\Google\\Chrome\\Application\\chrome.exe'))c.NotebookApp.browser = 'chrome' 其中C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe，这是你想要使用的浏览器路径，可通过右键点击浏览器快捷方式查看属性得到，chrome是你的浏览器名称，可修改，修改完成后，再次打开Jupyter Notebook，则自动打开浏览器编辑窗口最重要的一点是如果你使用的浏览器例如为msedge.exe无论你如何努力都不会有结果因为jupyter notebook不支持 哈哈哈傻了吧我也被坑过 2. 为jupyter设置默认目录1、目标：在C:\\...\\jupyter-notebook-script.py与%USERPROFILE%之间加入要默认的目录地址，如 E:\\jupyter（两边加空格）2、 起始位置改为：E:\\jupyter （为你的存储的位置）然后点击应用，并确定。就可以了！","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"C++cmach基本库","slug":"c-cmach基本库","date":"2019-09-19T09:25:18.000Z","updated":"2020-04-25T10:29:47.495Z","comments":true,"path":"2019/09/19/c-cmach基本库/","link":"","permalink":"http://yoursite.com/2019/09/19/c-cmach基本库/","excerpt":"c++的标准库cmath常用函数1. 求解绝对值123int abs(int i); //返回整型参数i的绝对值 double fabs(double i);//返回双精度参数i的绝对值 long labs(long n);//返回长整型参数i的绝对值","text":"c++的标准库cmath常用函数1. 求解绝对值123int abs(int i); //返回整型参数i的绝对值 double fabs(double i);//返回双精度参数i的绝对值 long labs(long n);//返回长整型参数i的绝对值 2. 求解指数函数123double exp(double x);//返回e^x的值int pow(int x,int y);//返回x^y的值，其他数据类型也一样int pow10(int x);//返回10^x 3. 求余数1float fmod(float x,float y); //求x除以y的余数 4. 求解对数函数12double log(double x);//返回loge(x)的值double log10(double x);////返回log10(x)的值 5. 开根号1double sqrt(double x); //返回√x的值 6. 三角函数求解12double asin(double x);//返回x的反正弦函数值，x为弧度 double sin(double x);//返回x的正弦函数值，x为弧度 7. 取整12double ceil(double x);//返回不小于x的最小整数double floor(double x);//返回不大于x的最大整数 http://poj.org/showmessage?message_id=349564","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"github代码上传","slug":"github代码上传","date":"2019-09-19T05:50:59.000Z","updated":"2019-09-24T11:29:15.409Z","comments":true,"path":"2019/09/19/github代码上传/","link":"","permalink":"http://yoursite.com/2019/09/19/github代码上传/","excerpt":"1.准备工作1）安装Git Bash因为这个是国外的软件是被限制的，推荐挂个代理本文推荐一个代理软件链接：https://pan.baidu.com/s/1trPZKgaAxktM8Il9OpxwvA提取码：xfhn目前本人正在使用的一个代理链接：https://www.52jying.com/nobe如果崩了大家可以上网百度一个自己找一个代理网址。","text":"1.准备工作1）安装Git Bash因为这个是国外的软件是被限制的，推荐挂个代理本文推荐一个代理软件链接：https://pan.baidu.com/s/1trPZKgaAxktM8Il9OpxwvA提取码：xfhn目前本人正在使用的一个代理链接：https://www.52jying.com/nobe如果崩了大家可以上网百度一个自己找一个代理网址。 2） 配置SSH keyssh key是用来解决本地与服务器的连接问题的。打开git bash输入命令 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\ id_rsa.pub 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。2) 测试是否成功 1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示： 1Are you sure you want to continue connecting (yes/no)? 输入yes，然后会看到： 1Hi liuxianan! You've successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！此时你还需要配置： 3. 创建仓库 4. 上传代码1）创建目录在目录下右键打开git bash。（这里创建的是text）2) 将当前目录变为git管理仓库代码： 1$ git init 如图： 同理将本地仓库链接到GitHub远程仓库： 12$ git remote add orign https://github.com/upsilverfox/fox.git#这个只要写一次就好，其中https://github.com/upsilverfox/fox为你的仓库地址。 运行成功后本地目录下将会增加 .git 如下图所示： 这样本地仓库就配置好了。 3）进行测试将一篇holle_word的文本文件放入text文件夹中。 重新在text目录下右键打开git bash。输入代码： 123$ git add . #这是为了告诉git将文件转到了仓库$ git commit -m \"fist\" #对本次上传进行说明，一定要写,而且每次上传都要写$ git push -u orign master #上传代码 示例图： 这样就成功了，有什么问题联系作者哦，虽然不一定能解决，哈哈哈哈！ 4. 参考文献 https://shansan.top/2019/03/08/将本地项目推送到GitHub远程仓库/","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"hexo从零开始到搭建完整","slug":"hexo从零开始到搭建完整","date":"2019-09-18T13:50:46.000Z","updated":"2021-03-25T16:08:40.505Z","comments":true,"path":"2019/09/18/hexo从零开始到搭建完整/","link":"","permalink":"http://yoursite.com/2019/09/18/hexo从零开始到搭建完整/","excerpt":"1. 准备工作1）安装Git Bash因为这个是国外的软件是被限制的，推荐挂个代理本文推荐一个代理软件链接：https://pan.baidu.com/s/1trPZKgaAxktM8Il9OpxwvA提取码：xfhn目前本人正在使用的一个代理链接：https://www.52jying.com/nobe如果崩了大家可以上网百度一个自己找一个代理网址。","text":"1. 准备工作1）安装Git Bash因为这个是国外的软件是被限制的，推荐挂个代理本文推荐一个代理软件链接：https://pan.baidu.com/s/1trPZKgaAxktM8Il9OpxwvA提取码：xfhn目前本人正在使用的一个代理链接：https://www.52jying.com/nobe如果崩了大家可以上网百度一个自己找一个代理网址。 2）安装node.js、npm3） 有一个GitHub账号 2. GitHub创建仓库和一些小细节1）GitHub账号创建后邮箱需要进行验证，如果想要在手机上进行验证需要将电脑上的GitHub账号退出登录。邮箱验证完毕后需要将邮箱进行公开，因为GitHub默认为private。 2）创建GitHub仓库 3. 配置SSH keyssh key是用来解决本地与服务器的连接问题的。1）打开git bash输入命令 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\ id_rsa.pub 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将刚复制的内容粘贴到key那里，title随便填，保存。2) 测试是否成功 1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示： 1Are you sure you want to continue connecting (yes/no)? 输入yes，然后会看到： 1Hi liuxianan! You've successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！此时你还需要配置： 12$ git config --global user.name \"liuxianan\"// 你的github用户名，非昵称$ git config --global user.email \"xxx@qq.com\"//填写你GitHub注册的邮箱 4. hexo的安装与配置1）hexo安装代码在电脑的某个地方新建blog一个文件夹（文件名可以随意取），该文件夹是用来存放代码的地方，鼠标右键点击文件夹，选择git bash指令输入代码(之后的命令都是这样操作) 12npm install -g hexohexo init hexo就会自动生成一些文件到你blog目录下，之后的操作都在这个目录下进行的。 2）测试效果 12$hexo g #生成$hexo s #启动服务 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html 3) 修改主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。个人比较喜欢的一个个主题 https://github.com/litten/hexo-theme-yilia 修改_config.yml中的theme: landscape改为theme: yilia，（yilia为你复制下来的文件名）然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布 4）上传github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。首先，ssh key肯定要配置好。其次，配置_config.yml中有关deploy的部分： 1234deploy: type: git repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 其中https://github.com/liuxianan/liuxianan.github.io.git为你创建仓库里的网址安装插件 1npm install hexo-deployer-git --save 5) 常见的一些hexo命令 1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 上传组合命令 123组合命令：hexo s -g #生成并本地预览hexo d -g #生成并上传 5. 写博客1）定位到我们的blog根目录下，输入代码： hexo new 'my-first-work' hexo会帮我们在_posts下生成相关md文件： 我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： 2）推荐一款写博客的软件Visual Studio Code链接：https://code.visualstudio.com/下载完后可还可以在软件里面下载markdown 图片上传推荐免费图床工具链接：https://www.itrhx.com/2019/08/01/A27-image-hosting/ 6. 参考 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html http://www.cnblogs.com/zhcncn/p/4097881.html http://www.jianshu.com/p/05289a4bc8b2 https://www.itrhx.com/2019/08/01/A27-image-hosting/","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"刷机教程","slug":"刷机教程","date":"2019-09-18T10:14:00.000Z","updated":"2019-09-25T09:49:55.478Z","comments":true,"path":"2019/09/18/刷机教程/","link":"","permalink":"http://yoursite.com/2019/09/18/刷机教程/","excerpt":"1. 前言 电脑系统崩溃了，必须得安装系统，以下是本人归类装机的教程 2. 准备工作 自带两个U盘，一个U盘来制作装机U盘，另一个U盘用来下载window10的镜像 3.下载制作U盘软件制作装机U盘这里使用的是PE工具箱。","text":"1. 前言 电脑系统崩溃了，必须得安装系统，以下是本人归类装机的教程 2. 准备工作 自带两个U盘，一个U盘来制作装机U盘，另一个U盘用来下载window10的镜像 3.下载制作U盘软件制作装机U盘这里使用的是PE工具箱。 链接: https://pan.baidu.com/s/1smOthvlX3JQJNecebcO35A提取码：opn0 下载的软件存放到用来制作装机U盘中，打开程序安装示意图如下： 1）推荐使用自定义的安装 2）在安装方法处建议选择方案三，U盘卷标为你的U盘名，pe壁纸下建议全选，当然不全选也行。然后点击安装就行了。 4. 下载 windows10镜像 推荐链接：https://msdn.itellyou.cn/ 5. 开始进行刷机 1）将电脑重启，在电脑开机时不断给点击F12进入刷机系统。 2）将电脑磁盘进行分区打开分区助手： 点击快速分区： 记住磁盘类型要选择GPT,扇区选择4096，选择完后点击开始执行 4）将电脑格式化分区后插入你下载好window10镜像的U盘，点击安装包就可以安装了。记住在安装完window10时电脑会关机，当电脑关机时要将U盘拔出。 示意图： 6. 装好系统后安装Windows10后，windows10是未激活状态，下面推荐一款Windows10（激活）工具链接：https://pan.baidu.com/s/1hV9lNjew_Ne1drM216e9-A提取码：l6cx还有一款office（激活）工具链接：https://pan.baidu.com/s/1KEahExeIv95iekWLaNpiRw提取码：a7fw还有什么不懂可以留言！！！","categories":[{"name":"刷机教程","slug":"刷机教程","permalink":"http://yoursite.com/categories/刷机教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]}]}